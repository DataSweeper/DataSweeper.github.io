define('dummy/tests/acceptance/authentication-test', ['exports', 'ember', 'mocha', 'chai', 'dummy/tests/helpers/start-app', 'pretender', 'dummy/tests/helpers/ember-simple-auth', 'dummy/tests/helpers/destroy-app', 'dummy/config/environment'], function (exports, _ember, _mocha, _chai, _dummyTestsHelpersStartApp, _pretender, _dummyTestsHelpersEmberSimpleAuth, _dummyTestsHelpersDestroyApp, _dummyConfigEnvironment) {

  (0, _mocha.describe)('Acceptance: Authentication', function () {
    var application = undefined;
    var server = undefined;

    (0, _mocha.beforeEach)(function () {
      application = (0, _dummyTestsHelpersStartApp['default'])();
    });

    (0, _mocha.afterEach)(function () {
      _ember['default'].tryInvoke(server, 'shutdown');
      (0, _dummyTestsHelpersDestroyApp['default'])(application);
    });

    (0, _mocha.describe)('the protected route', function () {
      (0, _mocha.it)('cannot be visited when the session is not authenticated', function () {
        (0, _dummyTestsHelpersEmberSimpleAuth.invalidateSession)(application);
        visit('/protected');

        return andThen(function () {
          (0, _chai.expect)(currentPath()).to.eq('login');
        });
      });

      (0, _mocha.it)('can be visited when the session is authenticated', function () {
        server = new _pretender['default'](function () {
          this.get(_dummyConfigEnvironment['default'].apiHost + '/posts', function () {
            return [200, { 'Content-Type': 'application/json' }, '{"data":[]}'];
          });
        });
        (0, _dummyTestsHelpersEmberSimpleAuth.authenticateSession)(application, { userId: 1, otherData: 'some-data' });

        visit('/protected');

        return andThen(function () {
          (0, _chai.expect)(currentPath()).to.eq('protected');
          var session = (0, _dummyTestsHelpersEmberSimpleAuth.currentSession)(application);
          (0, _chai.expect)(session.get('data.authenticated.userId')).to.eql(1);
          (0, _chai.expect)(session.get('data.authenticated.otherData')).to.eql('some-data');
        });
      });
    });

    (0, _mocha.describe)('the login route', function () {
      (0, _mocha.it)('can be visited when the session is not authenticated', function () {
        (0, _dummyTestsHelpersEmberSimpleAuth.invalidateSession)(application);
        visit('/login');

        return andThen(function () {
          (0, _chai.expect)(currentPath()).to.eq('login');
        });
      });

      (0, _mocha.it)('cannot be visited when the session is authenticated', function () {
        (0, _dummyTestsHelpersEmberSimpleAuth.authenticateSession)(application);
        visit('/login');

        return andThen(function () {
          (0, _chai.expect)(currentPath()).to.eq('index');
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/acceptance/authentication-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - acceptance/authentication-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'acceptance/authentication-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/acceptance/authentication-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - acceptance/authentication-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'acceptance/authentication-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/adapters/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - adapters/application.js', function () {
    it('should pass jscs', function () {
      expect(true, 'adapters/application.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/adapters/application.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - adapters/application.js', function () {
    it('should pass jshint', function () {
      expect(true, 'adapters/application.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/app.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - app.js', function () {
    it('should pass jscs', function () {
      expect(true, 'app.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/app.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - app.js', function () {
    it('should pass jshint', function () {
      expect(true, 'app.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/authenticators/oauth2.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - authenticators/oauth2.js', function () {
    it('should pass jscs', function () {
      expect(true, 'authenticators/oauth2.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/authenticators/oauth2.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - authenticators/oauth2.js', function () {
    it('should pass jshint', function () {
      expect(true, 'authenticators/oauth2.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/authenticators/torii.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - authenticators/torii.js', function () {
    it('should pass jscs', function () {
      expect(true, 'authenticators/torii.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/authenticators/torii.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - authenticators/torii.js', function () {
    it('should pass jshint', function () {
      expect(true, 'authenticators/torii.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/authorizers/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - authorizers/application.js', function () {
    it('should pass jscs', function () {
      expect(true, 'authorizers/application.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/authorizers/application.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - authorizers/application.js', function () {
    it('should pass jshint', function () {
      expect(true, 'authorizers/application.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/components/login-form.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - components/login-form.js', function () {
    it('should pass jscs', function () {
      expect(true, 'components/login-form.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/components/login-form.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - components/login-form.js', function () {
    it('should pass jshint', function () {
      expect(true, 'components/login-form.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/components/main-navigation.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - components/main-navigation.js', function () {
    it('should pass jscs', function () {
      expect(true, 'components/main-navigation.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/components/main-navigation.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - components/main-navigation.js', function () {
    it('should pass jshint', function () {
      expect(true, 'components/main-navigation.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/controllers/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - controllers/application.js', function () {
    it('should pass jscs', function () {
      expect(true, 'controllers/application.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/controllers/application.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - controllers/application.js', function () {
    it('should pass jshint', function () {
      expect(true, 'controllers/application.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/destroy-app', ['exports', 'ember'], function (exports, _ember) {
  exports['default'] = destroyApp;

  function destroyApp(application) {
    _ember['default'].run(application, 'destroy');
  }
});
define('dummy/tests/helpers/destroy-app.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - helpers/destroy-app.js', function () {
    it('should pass jscs', function () {
      expect(true, 'helpers/destroy-app.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/destroy-app.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - helpers/destroy-app.js', function () {
    it('should pass jshint', function () {
      expect(true, 'helpers/destroy-app.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/ember-simple-auth', ['exports', 'ember-simple-auth/authenticators/test'], function (exports, _emberSimpleAuthAuthenticatorsTest) {
  exports.authenticateSession = authenticateSession;
  exports.currentSession = currentSession;
  exports.invalidateSession = invalidateSession;

  var TEST_CONTAINER_KEY = 'authenticator:test';

  function ensureAuthenticator(app, container) {
    var authenticator = container.lookup(TEST_CONTAINER_KEY);
    if (!authenticator) {
      app.register(TEST_CONTAINER_KEY, _emberSimpleAuthAuthenticatorsTest['default']);
    }
  }

  function authenticateSession(app, sessionData) {
    var container = app.__container__;

    var session = container.lookup('service:session');
    ensureAuthenticator(app, container);
    session.authenticate(TEST_CONTAINER_KEY, sessionData);
    return wait();
  }

  ;

  function currentSession(app) {
    return app.__container__.lookup('service:session');
  }

  ;

  function invalidateSession(app) {
    var session = app.__container__.lookup('service:session');
    if (session.get('isAuthenticated')) {
      session.invalidate();
    }
    return wait();
  }

  ;
});
define('dummy/tests/helpers/fake-cookie-service', ['exports', 'ember'], function (exports, _ember) {
  var isNone = _ember['default'].isNone;
  exports['default'] = _ember['default'].Object.extend({
    init: function init() {
      this._super.apply(this, arguments);

      this._content = {};
    },

    read: function read(name) {
      var value = this._content[name];

      if (isNone(value)) {
        return value;
      } else {
        return decodeURIComponent(value);
      }
    },

    write: function write(name, value) {
      if (isNone(value)) {
        delete this._content[name];
      } else {
        this._content[name] = encodeURIComponent(value);
      }
    }
  });
});
define('dummy/tests/helpers/fake-cookie-service.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - helpers/fake-cookie-service.js', function () {
    it('should pass jscs', function () {
      expect(true, 'helpers/fake-cookie-service.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/fake-cookie-service.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - helpers/fake-cookie-service.js', function () {
    it('should pass jshint', function () {
      expect(true, 'helpers/fake-cookie-service.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/module-for-acceptance', ['exports', 'qunit', 'dummy/tests/helpers/start-app', 'dummy/tests/helpers/destroy-app'], function (exports, _qunit, _dummyTestsHelpersStartApp, _dummyTestsHelpersDestroyApp) {
  exports['default'] = function (name) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    (0, _qunit.module)(name, {
      beforeEach: function beforeEach() {
        this.application = (0, _dummyTestsHelpersStartApp['default'])();

        if (options.beforeEach) {
          // jscs:disable requireSpread
          options.beforeEach.apply(this, arguments);
          // jscs:enable requireSpread
        }
      },

      afterEach: function afterEach() {
        if (options.afterEach) {
          // jscs:disable requireSpread
          options.afterEach.apply(this, arguments);
          // jscs:enable requireSpread
        }

        (0, _dummyTestsHelpersDestroyApp['default'])(this.application);
      }
    });
  };
});
define('dummy/tests/helpers/module-for-acceptance.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - helpers/module-for-acceptance.js', function () {
    it('should pass jscs', function () {
      expect(true, 'helpers/module-for-acceptance.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/module-for-acceptance.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - helpers/module-for-acceptance.js', function () {
    it('should pass jshint', function () {
      expect(true, 'helpers/module-for-acceptance.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/resolver', ['exports', 'dummy/resolver', 'dummy/config/environment'], function (exports, _dummyResolver, _dummyConfigEnvironment) {

  var resolver = _dummyResolver['default'].create();

  resolver.namespace = {
    modulePrefix: _dummyConfigEnvironment['default'].modulePrefix,
    podModulePrefix: _dummyConfigEnvironment['default'].podModulePrefix
  };

  exports['default'] = resolver;
});
define('dummy/tests/helpers/resolver.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - helpers/resolver.js', function () {
    it('should pass jscs', function () {
      expect(true, 'helpers/resolver.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/resolver.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - helpers/resolver.js', function () {
    it('should pass jshint', function () {
      expect(true, 'helpers/resolver.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/start-app', ['exports', 'ember', 'dummy/app', 'dummy/config/environment'], function (exports, _ember, _dummyApp, _dummyConfigEnvironment) {
  exports['default'] = startApp;

  function startApp(attrs) {
    var application = undefined;

    var attributes = _ember['default'].merge({}, _dummyConfigEnvironment['default'].APP);
    attributes = _ember['default'].merge(attributes, attrs); // use defaults, but you can override;

    _ember['default'].run(function () {
      application = _dummyApp['default'].create(attributes);
      application.setupForTesting();
      application.injectTestHelpers();
    });

    return application;
  }
});
define('dummy/tests/helpers/start-app.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - helpers/start-app.js', function () {
    it('should pass jscs', function () {
      expect(true, 'helpers/start-app.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/start-app.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - helpers/start-app.js', function () {
    it('should pass jshint', function () {
      expect(true, 'helpers/start-app.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/helpers/torii', ['exports'], function (exports) {
  exports.stubValidSession = stubValidSession;

  function stubValidSession(application, sessionData) {
    var session = application.__container__.lookup('service:session');
    var sm = session.get('stateMachine');
    Ember.run(function () {
      sm.send('startOpen');
      sm.send('finishOpen', sessionData);
    });
  }
});
define('dummy/tests/models/account.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - models/account.js', function () {
    it('should pass jscs', function () {
      expect(true, 'models/account.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/models/account.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - models/account.js', function () {
    it('should pass jshint', function () {
      expect(true, 'models/account.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/models/post.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - models/post.js', function () {
    it('should pass jscs', function () {
      expect(true, 'models/post.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/models/post.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - models/post.js', function () {
    it('should pass jshint', function () {
      expect(true, 'models/post.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/resolver.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - resolver.js', function () {
    it('should pass jscs', function () {
      expect(true, 'resolver.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/resolver.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - resolver.js', function () {
    it('should pass jshint', function () {
      expect(true, 'resolver.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/router.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - router.js', function () {
    it('should pass jscs', function () {
      expect(true, 'router.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/router.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - router.js', function () {
    it('should pass jshint', function () {
      expect(true, 'router.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - routes/application.js', function () {
    it('should pass jscs', function () {
      expect(true, 'routes/application.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/application.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - routes/application.js', function () {
    it('should pass jshint', function () {
      expect(true, 'routes/application.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/auth-error.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - routes/auth-error.js', function () {
    it('should pass jscs', function () {
      expect(true, 'routes/auth-error.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/auth-error.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - routes/auth-error.js', function () {
    it('should pass jshint', function () {
      expect(true, 'routes/auth-error.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/login.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - routes/login.js', function () {
    it('should pass jscs', function () {
      expect(true, 'routes/login.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/login.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - routes/login.js', function () {
    it('should pass jshint', function () {
      expect(true, 'routes/login.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/protected.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - routes/protected.js', function () {
    it('should pass jscs', function () {
      expect(true, 'routes/protected.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/routes/protected.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - routes/protected.js', function () {
    it('should pass jshint', function () {
      expect(true, 'routes/protected.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/services/session-account.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - services/session-account.js', function () {
    it('should pass jscs', function () {
      expect(true, 'services/session-account.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/services/session-account.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - services/session-account.js', function () {
    it('should pass jshint', function () {
      expect(true, 'services/session-account.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/session-stores/application.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - session-stores/application.js', function () {
    it('should pass jscs', function () {
      expect(true, 'session-stores/application.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/session-stores/application.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - session-stores/application.js', function () {
    it('should pass jshint', function () {
      expect(true, 'session-stores/application.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/test-helper', ['exports', 'npm:sinon-chai', 'chai', 'dummy/tests/helpers/resolver', 'ember-mocha'], function (exports, _npmSinonChai, _chai, _dummyTestsHelpersResolver, _emberMocha) {

  (0, _emberMocha.setResolver)(_dummyTestsHelpersResolver['default']);

  _chai['default'].use(_npmSinonChai['default']);
});
define('dummy/tests/test-helper.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - test-helper.js', function () {
    it('should pass jscs', function () {
      expect(true, 'test-helper.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/test-helper.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - test-helper.js', function () {
    it('should pass jshint', function () {
      expect(true, 'test-helper.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/torii-providers/facebook.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - torii-providers/facebook.js', function () {
    it('should pass jscs', function () {
      expect(true, 'torii-providers/facebook.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/torii-providers/facebook.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - torii-providers/facebook.js', function () {
    it('should pass jshint', function () {
      expect(true, 'torii-providers/facebook.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/base-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'ember-simple-auth/authenticators/base'], function (exports, _emberMocha, _mocha, _chai, _emberSimpleAuthAuthenticatorsBase) {

  (0, _mocha.describe)('BaseAuthenticator', function () {
    var authenticator = undefined;

    (0, _mocha.beforeEach)(function () {
      authenticator = _emberSimpleAuthAuthenticatorsBase['default'].create();
    });

    (0, _mocha.describe)('#restore', function () {
      (0, _emberMocha.it)('returns a rejecting promise', function (done) {
        authenticator.restore()['catch'](function () {
          (0, _chai.expect)(true).to.be['true'];
          done();
        });
      });
    });

    (0, _mocha.describe)('#authenticate', function () {
      (0, _emberMocha.it)('returns a rejecting promise', function (done) {
        authenticator.authenticate()['catch'](function () {
          (0, _chai.expect)(true).to.be['true'];
          done();
        });
      });
    });

    (0, _mocha.describe)('#invalidate', function () {
      (0, _emberMocha.it)('returns a resolving promise', function (done) {
        authenticator.invalidate().then(function () {
          (0, _chai.expect)(true).to.be['true'];
          done();
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/authenticators/base-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authenticators/base-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authenticators/base-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/base-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authenticators/base-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authenticators/base-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/devise-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/authenticators/devise'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthAuthenticatorsDevise) {
  var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

  (0, _mocha.describe)('DeviseAuthenticator', function () {
    var xhr = undefined;
    var server = undefined;
    var authenticator = undefined;

    (0, _mocha.beforeEach)(function () {
      xhr = _sinon['default'].useFakeXMLHttpRequest();
      server = _sinon['default'].fakeServer.create();
      server.autoRespond = true;
      authenticator = _emberSimpleAuthAuthenticatorsDevise['default'].create();
    });

    (0, _mocha.afterEach)(function () {
      xhr.restore();
    });

    (0, _mocha.describe)('#restore', function () {
      (0, _mocha.beforeEach)(function () {
        server.respondWith('POST', '/users/sign_in', [201, { 'Content-Type': 'application/json' }, '{ "user_token": "secret token!" }']);
      });

      (0, _mocha.describe)('when the data contains a token and email', function () {
        (0, _emberMocha.it)('resolves with the correct data', function (done) {
          authenticator.restore({ token: 'secret token!', email: 'user@email.com' }).then(function (content) {
            (0, _chai.expect)(content).to.eql({ token: 'secret token!', email: 'user@email.com' });
            done();
          });
        });
      });

      (0, _mocha.describe)('when the data contains a custom token and email attribute', function () {
        (0, _mocha.beforeEach)(function () {
          authenticator = _emberSimpleAuthAuthenticatorsDevise['default'].extend({ tokenAttributeName: 'employee.token', identificationAttributeName: 'employee.email' }).create();
        });

        (0, _emberMocha.it)('resolves with the correct data', function (done) {
          authenticator.restore({ employee: { token: 'secret token!', email: 'user@email.com' } }).then(function (content) {
            (0, _chai.expect)(content).to.eql({ employee: { token: 'secret token!', email: 'user@email.com' } });
            done();
          });
        });
      });
    });

    (0, _mocha.describe)('#authenticate', function () {
      (0, _mocha.beforeEach)(function () {
        _sinon['default'].spy(_ember['default'].$, 'ajax');
      });

      (0, _mocha.afterEach)(function () {
        _ember['default'].$.ajax.restore();
      });

      (0, _emberMocha.it)('sends an AJAX request to the sign in endpoint', function (done) {
        authenticator.authenticate('identification', 'password');

        _ember['default'].run.next(function () {
          var _Ember$$$ajax$getCall$args = _slicedToArray(_ember['default'].$.ajax.getCall(0).args, 1);

          var args = _Ember$$$ajax$getCall$args[0];

          delete args.beforeSend;
          (0, _chai.expect)(args).to.eql({
            url: '/users/sign_in',
            type: 'POST',
            data: { user: { email: 'identification', password: 'password' } },
            dataType: 'json'
          });
          done();
        });
      });

      (0, _mocha.describe)('when the authentication request is successful', function () {
        (0, _mocha.beforeEach)(function () {
          server.respondWith('POST', '/users/sign_in', [201, { 'Content-Type': 'application/json' }, '{ "access_token": "secret token!" }']);
        });

        (0, _emberMocha.it)('resolves with the correct data', function (done) {
          authenticator.authenticate('email@address.com', 'password').then(function (data) {
            (0, _chai.expect)(true).to.be['true'];
            (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token!' });
            done();
          });
        });
      });

      (0, _mocha.describe)('when the authentication request fails', function () {
        (0, _mocha.beforeEach)(function () {
          server.respondWith('POST', '/users/sign_in', [400, { 'Content-Type': 'application/json' }, '{ "error": "invalid_grant" }']);
        });

        (0, _emberMocha.it)('rejects with the correct error', function (done) {
          authenticator.authenticate('email@address.com', 'password')['catch'](function (error) {
            (0, _chai.expect)(error).to.eql({ error: 'invalid_grant' });
            done();
          });
        });
      });

      (0, _emberMocha.it)('can customize the ajax request', function (done) {
        authenticator = _emberSimpleAuthAuthenticatorsDevise['default'].extend({
          makeRequest: function makeRequest(config) {
            return this._super(config, { contentType: 'application/json' });
          }
        }).create();
        authenticator.authenticate('identification', 'password');
        _ember['default'].run.next(function () {
          var _Ember$$$ajax$getCall$args2 = _slicedToArray(_ember['default'].$.ajax.getCall(0).args, 1);

          var args = _Ember$$$ajax$getCall$args2[0];

          (0, _chai.expect)(args.contentType).to.eql('application/json');
          done();
        });
      });
    });

    (0, _mocha.describe)('#invalidate', function () {
      (0, _emberMocha.it)('returns a resolving promise', function (done) {
        authenticator.invalidate().then(function () {
          (0, _chai.expect)(true).to.be['true'];
          done();
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/authenticators/devise-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authenticators/devise-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authenticators/devise-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/devise-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authenticators/devise-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authenticators/devise-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/oauth2-password-grant-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/authenticators/oauth2-password-grant'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthAuthenticatorsOauth2PasswordGrant) {

  (0, _mocha.describe)('OAuth2PasswordGrantAuthenticator', function () {
    var authenticator = undefined;
    var xhr = undefined;
    var server = undefined;

    (0, _mocha.beforeEach)(function () {
      authenticator = _emberSimpleAuthAuthenticatorsOauth2PasswordGrant['default'].create();
      xhr = _sinon['default'].useFakeXMLHttpRequest();
      server = _sinon['default'].fakeServer.create();
      server.autoRespond = true;
      _sinon['default'].spy(_ember['default'].$, 'ajax');
    });

    (0, _mocha.afterEach)(function () {
      xhr.restore();
      _ember['default'].$.ajax.restore();
    });

    (0, _mocha.describe)('#restore', function () {
      (0, _mocha.describe)('when the data includes expiration data', function () {
        (0, _emberMocha.it)('resolves with the correct data', function (done) {
          authenticator.restore({ 'access_token': 'secret token!', 'expires_in': 12345, 'refresh_token': 'refresh token!' }).then(function (data) {
            (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token!', 'expires_in': 12345, 'refresh_token': 'refresh token!' });
            done();
          });
        });

        (0, _mocha.describe)('when the data includes an expiration time in the past', function () {
          (0, _mocha.describe)('when automatic token refreshing is enabled', function () {
            (0, _mocha.describe)('when the refresh request is successful', function () {
              (0, _mocha.beforeEach)(function () {
                server.respondWith('POST', '/token', [200, { 'Content-Type': 'application/json' }, '{ "access_token": "secret token 2!", "expires_in": 67890, "refresh_token": "refresh token 2!" }']);
              });

              (0, _emberMocha.it)('resolves with the correct data', function (done) {
                authenticator.restore({ 'access_token': 'secret token!', 'expires_at': 1 }).then(function (data) {
                  (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());
                  delete data['expires_at'];
                  (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token 2!', 'expires_in': 67890, 'refresh_token': 'refresh token 2!' });
                  done();
                });
              });
            });

            (0, _mocha.describe)('when the access token is not refreshed successfully', function () {
              (0, _emberMocha.it)('returns a rejecting promise', function (done) {
                authenticator.restore({ 'access_token': 'secret token!', 'expires_at': 1 })['catch'](function () {
                  (0, _chai.expect)(true).to.be['true'];
                  done();
                });
              });
            });
          });

          (0, _mocha.describe)('when automatic token refreshing is disabled', function () {
            (0, _mocha.beforeEach)(function () {
              authenticator.set('refreshAccessTokens', false);
            });

            (0, _emberMocha.it)('returns a rejecting promise', function (done) {
              authenticator.restore({ 'access_token': 'secret token!', 'expires_at': 1 })['catch'](function () {
                (0, _chai.expect)(true).to.be['true'];
                done();
              });
            });
          });
        });
      });

      (0, _mocha.describe)('when the data does not include expiration data', function () {
        (0, _mocha.describe)('when the data contains an access_token', function () {
          (0, _emberMocha.it)('resolves with the correct data', function (done) {
            authenticator.restore({ 'access_token': 'secret token!' }).then(function (data) {
              (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token!' });
              done();
            });
          });
        });

        (0, _mocha.describe)('when the data does not contain an access_token', function () {
          (0, _emberMocha.it)('returns a rejecting promise', function (done) {
            authenticator.restore()['catch'](function () {
              (0, _chai.expect)(true).to.be['true'];
              done();
            });
          });
        });
      });
    });

    (0, _mocha.describe)('#authenticate', function () {
      (0, _emberMocha.it)('sends an AJAX request to the token endpoint', function (done) {
        authenticator.authenticate('username', 'password');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(_ember['default'].$.ajax.getCall(0).args[0]).to.eql({
            url: '/token',
            type: 'POST',
            data: { 'grant_type': 'password', username: 'username', password: 'password' },
            dataType: 'json',
            contentType: 'application/x-www-form-urlencoded'
          });
          done();
        });
      });

      (0, _emberMocha.it)('sends an AJAX request to the token endpoint with client_id Basic Auth header', function (done) {
        authenticator.set('clientId', 'test-client');
        authenticator.authenticate('username', 'password');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(_ember['default'].$.ajax.getCall(0).args[0]).to.eql({
            url: '/token',
            type: 'POST',
            data: { 'grant_type': 'password', username: 'username', password: 'password' },
            dataType: 'json',
            contentType: 'application/x-www-form-urlencoded',
            headers: { Authorization: 'Basic dGVzdC1jbGllbnQ6' }
          });
          done();
        });
      });

      (0, _emberMocha.it)('sends a single OAuth scope to the token endpoint', function (done) {
        authenticator.authenticate('username', 'password', 'public');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(_ember['default'].$.ajax.getCall(0).args[0].data.scope).to.eql('public');
          done();
        });
      });

      (0, _emberMocha.it)('sends multiple OAuth scopes to the token endpoint', function (done) {
        authenticator.authenticate('username', 'password', ['public', 'private']);

        _ember['default'].run.next(function () {
          (0, _chai.expect)(_ember['default'].$.ajax.getCall(0).args[0].data.scope).to.eql('public private');
          done();
        });
      });

      (0, _mocha.describe)('when the authentication request is successful', function () {
        (0, _mocha.beforeEach)(function () {
          server.respondWith('POST', '/token', [200, { 'Content-Type': 'application/json' }, '{ "access_token": "secret token!" }']);
        });

        (0, _emberMocha.it)('resolves with the correct data', function (done) {
          authenticator.authenticate('username', 'password').then(function (data) {
            (0, _chai.expect)(true).to.be['true'];
            (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token!' });
            done();
          });
        });

        (0, _mocha.describe)('when the server response includes expiration data', function () {
          (0, _mocha.beforeEach)(function () {
            server.respondWith('POST', '/token', [200, { 'Content-Type': 'application/json' }, '{ "access_token": "secret token!", "expires_in": 12345, "refresh_token": "refresh token!" }']);
          });

          (0, _emberMocha.it)('resolves with the correct data', function (done) {
            authenticator.authenticate('username', 'password').then(function (data) {
              (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());
              delete data['expires_at'];
              (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token!', 'expires_in': 12345, 'refresh_token': 'refresh token!' });
              done();
            });
          });
        });
      });

      (0, _mocha.describe)('when the authentication request fails', function () {
        (0, _mocha.beforeEach)(function () {
          server.respondWith('POST', '/token', [400, { 'Content-Type': 'application/json' }, '{ "error": "invalid_grant" }']);
        });

        (0, _emberMocha.it)('rejects with the correct error', function (done) {
          authenticator.authenticate('username', 'password')['catch'](function (error) {
            (0, _chai.expect)(error).to.eql({ error: 'invalid_grant' });
            done();
          });
        });
      });
    });

    (0, _mocha.describe)('#invalidate', function () {
      function itSuccessfullyInvalidatesTheSession() {
        (0, _emberMocha.it)('returns a resolving promise', function (done) {
          authenticator.invalidate({ 'access_token': 'access token!' }).then(function () {
            (0, _chai.expect)(true).to.be['true'];
            done();
          });
        });
      }

      (0, _mocha.describe)('when token revokation is enabled', function () {
        (0, _mocha.beforeEach)(function () {
          authenticator.serverTokenRevocationEndpoint = '/revoke';
        });

        (0, _emberMocha.it)('sends an AJAX request to the revokation endpoint', function (done) {
          authenticator.invalidate({ 'access_token': 'access token!' });

          _ember['default'].run.next(function () {
            (0, _chai.expect)(_ember['default'].$.ajax.getCall(0).args[0]).to.eql({
              url: '/revoke',
              type: 'POST',
              data: { 'token_type_hint': 'access_token', token: 'access token!' },
              dataType: 'json',
              contentType: 'application/x-www-form-urlencoded'
            });
            done();
          });
        });

        (0, _mocha.describe)('when the revokation request is successful', function () {
          (0, _mocha.beforeEach)(function () {
            server.respondWith('POST', '/revoke', [200, { 'Content-Type': 'application/json' }, '']);
          });

          itSuccessfullyInvalidatesTheSession();
        });

        (0, _mocha.describe)('when the revokation request fails', function () {
          (0, _mocha.beforeEach)(function () {
            server.respondWith('POST', '/revoke', [400, { 'Content-Type': 'application/json' }, '{ "error": "unsupported_grant_type" }']);
          });

          itSuccessfullyInvalidatesTheSession();
        });

        (0, _mocha.describe)('when a refresh token is set', function () {
          (0, _emberMocha.it)('sends an AJAX request to invalidate the refresh token', function (done) {
            authenticator.invalidate({ 'access_token': 'access token!', 'refresh_token': 'refresh token!' });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(_ember['default'].$.ajax.getCall(1).args[0]).to.eql({
                url: '/revoke',
                type: 'POST',
                data: { 'token_type_hint': 'refresh_token', token: 'refresh token!' },
                dataType: 'json',
                contentType: 'application/x-www-form-urlencoded'
              });
              done();
            });
          });
        });
      });

      (0, _mocha.describe)('when token revokation is not enabled', function () {
        itSuccessfullyInvalidatesTheSession();
      });
    });

    // testing private API here ;(
    (0, _mocha.describe)('#_refreshAccessToken', function () {
      (0, _emberMocha.it)('sends an AJAX request to the token endpoint', function (done) {
        authenticator._refreshAccessToken(12345, 'refresh token!');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(_ember['default'].$.ajax.getCall(0).args[0]).to.eql({
            url: '/token',
            type: 'POST',
            data: { 'grant_type': 'refresh_token', 'refresh_token': 'refresh token!' },
            dataType: 'json',
            contentType: 'application/x-www-form-urlencoded'
          });
          done();
        });
      });

      (0, _mocha.describe)('when the refresh request is successful', function () {
        (0, _mocha.beforeEach)(function () {
          server.respondWith('POST', '/token', [200, { 'Content-Type': 'application/json' }, '{ "access_token": "secret token 2!" }']);
        });

        (0, _emberMocha.it)('triggers the "sessionDataUpdated" event', function (done) {
          authenticator.one('sessionDataUpdated', function (data) {
            (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());
            delete data['expires_at'];
            (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token 2!', 'expires_in': 12345, 'refresh_token': 'refresh token!' });
            done();
          });

          authenticator._refreshAccessToken(12345, 'refresh token!');
        });

        (0, _mocha.describe)('when the server reponse includes updated expiration data', function () {
          (0, _mocha.beforeEach)(function () {
            server.respondWith('POST', '/token', [200, { 'Content-Type': 'application/json' }, '{ "access_token": "secret token 2!", "expires_in": 67890, "refresh_token": "refresh token 2!" }']);
          });

          (0, _emberMocha.it)('triggers the "sessionDataUpdated" event with the correct data', function (done) {
            authenticator.one('sessionDataUpdated', function (data) {
              (0, _chai.expect)(data['expires_at']).to.be.greaterThan(new Date().getTime());
              delete data['expires_at'];
              (0, _chai.expect)(data).to.eql({ 'access_token': 'secret token 2!', 'expires_in': 67890, 'refresh_token': 'refresh token 2!' });
              done();
            });

            authenticator._refreshAccessToken(12345, 'refresh token!');
          });
        });
      });
    });
  });
});
/* jshint expr:true */
/* jscs:disable requireDotNotation */
define('dummy/tests/unit/authenticators/oauth2-password-grant-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authenticators/oauth2-password-grant-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authenticators/oauth2-password-grant-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/oauth2-password-grant-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authenticators/oauth2-password-grant-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authenticators/oauth2-password-grant-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/test-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'ember-simple-auth/authenticators/test'], function (exports, _emberMocha, _mocha, _chai, _emberSimpleAuthAuthenticatorsTest) {

  (0, _mocha.describe)('TestAuthenticator', function () {
    var authenticator = undefined;

    (0, _mocha.beforeEach)(function () {
      authenticator = _emberSimpleAuthAuthenticatorsTest['default'].create();
    });

    (0, _mocha.describe)('#restore', function () {
      (0, _emberMocha.it)('returns a resolving promise', function () {
        return authenticator.restore().then(function () {
          (0, _chai.expect)(true).to.be['true'];
        });
      });

      (0, _emberMocha.it)('resolves with session data', function () {
        return authenticator.restore({ userId: 1, otherData: 'some-data' }).then(function (data) {
          (0, _chai.expect)(data).to.eql({ userId: 1, otherData: 'some-data' });
        });
      });
    });

    (0, _mocha.describe)('#authenticate', function () {
      (0, _emberMocha.it)('returns a resolving promise', function () {
        return authenticator.authenticate().then(function () {
          (0, _chai.expect)(true).to.be['true'];
        });
      });

      (0, _emberMocha.it)('resolves with session data', function () {
        return authenticator.authenticate({ userId: 1, otherData: 'some-data' }).then(function (data) {
          (0, _chai.expect)(data).to.eql({ userId: 1, otherData: 'some-data' });
        });
      });
    });

    (0, _mocha.describe)('#invalidate', function () {
      (0, _emberMocha.it)('returns a resolving promise', function () {
        return authenticator.invalidate().then(function () {
          (0, _chai.expect)(true).to.be['true'];
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/authenticators/test-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authenticators/test-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authenticators/test-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/test-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authenticators/test-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authenticators/test-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/torii-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/authenticators/torii'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthAuthenticatorsTorii) {

  (0, _mocha.describe)('ToriiAuthenticator', function () {
    var authenticator = undefined;
    var torii = undefined;

    (0, _mocha.beforeEach)(function () {
      torii = {
        fetch: function fetch() {},
        open: function open() {},
        close: function close() {}
      };
      authenticator = _emberSimpleAuthAuthenticatorsTorii['default'].create({ torii: torii });
    });

    (0, _mocha.describe)('#restore', function () {
      function itDoesNotRestore(data) {
        (0, _emberMocha.it)('returns a rejecting promise', function () {
          return authenticator.restore(data)['catch'](function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });
      }

      (0, _emberMocha.it)('throws if torii is not installed', function () {
        authenticator.set('torii', null);

        (0, _chai.expect)(function () {
          authenticator.authenticate();
        }).to['throw'];
      });

      (0, _mocha.describe)('when there is a torii provider in the session data', function () {
        (0, _mocha.describe)('when torii fetches successfully', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(torii, 'fetch').returns(_ember['default'].RSVP.resolve({ some: 'other data' }));
          });

          (0, _emberMocha.it)('returns a promise that resolves with the session data', function () {
            return authenticator.restore({ some: 'data', provider: 'provider' }).then(function (data) {
              (0, _chai.expect)(data).to.eql({ some: 'other data', provider: 'provider' });
            });
          });
        });

        (0, _mocha.describe)('when torii does not fetch successfully', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(torii, 'fetch').returns(_ember['default'].RSVP.reject());
          });

          itDoesNotRestore({ some: 'data', provider: 'provider' });
        });
      });

      (0, _mocha.describe)('when there is no torii provider in the session data', function () {
        itDoesNotRestore();
      });
    });

    (0, _mocha.describe)('#authenticate', function () {
      (0, _emberMocha.it)('throws if torii is not installed', function () {
        authenticator.set('torii', null);

        (0, _chai.expect)(function () {
          authenticator.authenticate();
        }).to['throw'];
      });

      (0, _mocha.describe)('when torii opens successfully', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(torii, 'open').returns(_ember['default'].RSVP.resolve({ some: 'data' }));
        });

        (0, _emberMocha.it)('returns a promise that resolves with the session data', function () {
          return authenticator.authenticate('provider').then(function (data) {
            (0, _chai.expect)(data).to.eql({ some: 'data', provider: 'provider' });
          });
        });
      });

      (0, _mocha.describe)('when torii does not open successfully', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(torii, 'open').returns(_ember['default'].RSVP.reject());
        });

        (0, _emberMocha.it)('returns a rejecting promise', function () {
          return authenticator.authenticate('provider')['catch'](function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });
      });
    });

    (0, _mocha.describe)('#invalidate', function () {
      (0, _mocha.describe)('when torii closes successfully', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(torii, 'close').returns(_ember['default'].RSVP.resolve());
        });

        (0, _emberMocha.it)('returns a resolving promise', function () {
          return authenticator.invalidate({ some: 'data' }).then(function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });
      });

      (0, _mocha.describe)('when torii does not close successfully', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(torii, 'close').returns(_ember['default'].RSVP.reject());
        });

        (0, _emberMocha.it)('returns a rejecting promise', function () {
          return authenticator.invalidate('provider')['catch'](function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/authenticators/torii-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authenticators/torii-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authenticators/torii-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authenticators/torii-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authenticators/torii-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authenticators/torii-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authorizers/devise-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/authorizers/devise'], function (exports, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthAuthorizersDevise) {

  (0, _mocha.describe)('DeviseAuthorizer', function () {
    var authorizer = undefined;
    var block = undefined;
    var data = undefined;

    (0, _mocha.beforeEach)(function () {
      authorizer = _emberSimpleAuthAuthorizersDevise['default'].create();
      block = _sinon['default'].spy();
    });

    (0, _mocha.describe)('#authorize', function () {
      function itDoesNotAuthorizeTheRequest() {
        (0, _emberMocha.it)('does not call the block', function () {
          authorizer.authorize(data, block);

          (0, _chai.expect)(block).to.not.have.been.called;
        });
      }

      (0, _mocha.describe)('when the session data contains a non empty token and email', function () {
        (0, _mocha.beforeEach)(function () {
          data = {
            token: 'secret token!',
            email: 'user@email.com'
          };
        });

        (0, _emberMocha.it)('calls the block with a header containing "token" and "email"', function () {
          authorizer.authorize(data, block);

          (0, _chai.expect)(block).to.have.been.calledWith('Authorization', 'Token token="secret token!", email="user@email.com"');
        });
      });

      (0, _mocha.describe)('when custom identification and token attribute names are configured', function () {
        (0, _mocha.beforeEach)(function () {
          authorizer = _emberSimpleAuthAuthorizersDevise['default'].extend({ tokenAttributeName: 'employee_token', identificationAttributeName: 'employee_email' }).create();
        });

        (0, _mocha.describe)('when the session data contains a non empty employee_token and employee_email', function () {
          (0, _mocha.beforeEach)(function () {
            data = {
              'employee_token': 'secret token!',
              'employee_email': 'user@email.com'
            };
          });

          (0, _emberMocha.it)('calls the block with a header containing "employee_token" and "employee_email"', function () {
            authorizer.authorize(data, block);

            (0, _chai.expect)(block).to.have.been.calledWith('Authorization', 'Token employee_token="secret token!", employee_email="user@email.com"');
          });
        });
      });

      (0, _mocha.describe)('when the session data does not contain a token', function () {
        (0, _mocha.beforeEach)(function () {
          data = {
            email: 'user@email.com'
          };
        });

        itDoesNotAuthorizeTheRequest();
      });

      (0, _mocha.describe)('when the session data does not contain an email', function () {
        (0, _mocha.beforeEach)(function () {
          data = {
            token: 'secret token!'
          };
        });

        itDoesNotAuthorizeTheRequest();
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/authorizers/devise-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authorizers/devise-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authorizers/devise-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authorizers/devise-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authorizers/devise-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authorizers/devise-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authorizers/oauth2-bearer-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/authorizers/oauth2-bearer'], function (exports, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthAuthorizersOauth2Bearer) {

  (0, _mocha.describe)('OAuth2BearerAuthorizer', function () {
    var authorizer = undefined;
    var data = undefined;
    var block = undefined;

    (0, _mocha.beforeEach)(function () {
      authorizer = _emberSimpleAuthAuthorizersOauth2Bearer['default'].create();
      block = _sinon['default'].spy();
    });

    (0, _mocha.describe)('#authorize', function () {
      function itDoesNotAuthorizeTheRequest() {
        (0, _emberMocha.it)('does not call the block', function () {
          authorizer.authorize(data, block);

          (0, _chai.expect)(block).to.not.have.been.called;
        });
      }

      (0, _mocha.describe)('when the session data contains a non empty access_token', function () {
        (0, _mocha.beforeEach)(function () {
          data = {
            'access_token': 'secret token!'
          };
        });

        (0, _emberMocha.it)('calls the block with a Bearer token header', function () {
          authorizer.authorize(data, block);

          (0, _chai.expect)(block).to.have.been.calledWith('Authorization', 'Bearer secret token!');
        });
      });

      (0, _mocha.describe)('when the session does not contain an access_token', function () {
        (0, _mocha.beforeEach)(function () {
          data = {};
        });

        itDoesNotAuthorizeTheRequest();
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/authorizers/oauth2-bearer-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/authorizers/oauth2-bearer-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/authorizers/oauth2-bearer-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/authorizers/oauth2-bearer-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/authorizers/oauth2-bearer-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/authorizers/oauth2-bearer-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/configuration-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'ember-simple-auth/configuration'], function (exports, _emberMocha, _mocha, _chai, _emberSimpleAuthConfiguration) {

  (0, _mocha.describe)('Configuration', function () {
    (0, _mocha.afterEach)(function () {
      _emberSimpleAuthConfiguration['default'].load({});
    });

    (0, _mocha.describe)('baseURL', function () {
      (0, _emberMocha.it)('defaults to ""', function () {
        _emberSimpleAuthConfiguration['default'].load({});

        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].baseURL).to.eql('');
      });
    });

    (0, _mocha.describe)('authenticationRoute', function () {
      (0, _emberMocha.it)('defaults to "login"', function () {
        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].authenticationRoute).to.eql('login');
      });
    });

    (0, _mocha.describe)('routeAfterAuthentication', function () {
      (0, _emberMocha.it)('defaults to "index"', function () {
        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].routeAfterAuthentication).to.eql('index');
      });
    });

    (0, _mocha.describe)('routeIfAlreadyAuthenticated', function () {
      (0, _emberMocha.it)('defaults to "index"', function () {
        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].routeIfAlreadyAuthenticated).to.eql('index');
      });
    });

    (0, _mocha.describe)('.load', function () {
      (0, _emberMocha.it)('sets baseURL correctly', function () {
        _emberSimpleAuthConfiguration['default'].load({ baseURL: '/baseURL' });

        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].baseURL).to.eql('/baseURL');
      });

      (0, _emberMocha.it)('sets authenticationRoute correctly', function () {
        _emberSimpleAuthConfiguration['default'].load({ authenticationRoute: 'authenticationRoute' });

        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].authenticationRoute).to.eql('authenticationRoute');
      });

      (0, _emberMocha.it)('sets routeAfterAuthentication correctly', function () {
        _emberSimpleAuthConfiguration['default'].load({ routeAfterAuthentication: 'routeAfterAuthentication' });

        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].routeAfterAuthentication).to.eql('routeAfterAuthentication');
      });

      (0, _emberMocha.it)('sets routeIfAlreadyAuthenticated correctly', function () {
        _emberSimpleAuthConfiguration['default'].load({ routeIfAlreadyAuthenticated: 'routeIfAlreadyAuthenticated' });

        (0, _chai.expect)(_emberSimpleAuthConfiguration['default'].routeIfAlreadyAuthenticated).to.eql('routeIfAlreadyAuthenticated');
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/configuration-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/configuration-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/configuration-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/configuration-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/configuration-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/configuration-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/initializers/setup-session-service-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/initializers/setup-session-service'], function (exports, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthInitializersSetupSessionService) {

  (0, _mocha.describe)('setupSessionService', function () {
    var registry = undefined;

    (0, _mocha.beforeEach)(function () {
      registry = {
        injection: function injection() {}
      };
    });

    (0, _emberMocha.it)('injects the session into the session service', function () {
      _sinon['default'].spy(registry, 'injection');
      (0, _emberSimpleAuthInitializersSetupSessionService['default'])(registry);

      (0, _chai.expect)(registry.injection).to.have.been.calledWith('service:session', 'session', 'session:main');
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/initializers/setup-session-service-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/initializers/setup-session-service-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/initializers/setup-session-service-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/initializers/setup-session-service-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/initializers/setup-session-service-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/initializers/setup-session-service-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/initializers/setup-session-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/initializers/setup-session', 'ember-simple-auth/session-stores/ephemeral', 'ember-simple-auth/internal-session'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthInitializersSetupSession, _emberSimpleAuthSessionStoresEphemeral, _emberSimpleAuthInternalSession) {

  (0, _mocha.describe)('setupSession', function () {
    var registry = undefined;

    (0, _mocha.beforeEach)(function () {
      registry = {
        register: function register() {},
        injection: function injection() {}
      };
    });

    (0, _emberMocha.it)('registers the session', function () {
      _sinon['default'].spy(registry, 'register');
      (0, _emberSimpleAuthInitializersSetupSession['default'])(registry);

      (0, _chai.expect)(registry.register).to.have.been.calledWith('session:main', _emberSimpleAuthInternalSession['default']);
    });

    (0, _mocha.describe)('when Ember.testing is true', function () {
      (0, _emberMocha.it)('registers the test session store', function () {
        _sinon['default'].spy(registry, 'register');
        (0, _emberSimpleAuthInitializersSetupSession['default'])(registry);

        (0, _chai.expect)(registry.register).to.have.been.calledWith('session-store:test', _emberSimpleAuthSessionStoresEphemeral['default']);
      });

      (0, _emberMocha.it)('injects the test session store into the session', function () {
        _sinon['default'].spy(registry, 'injection');
        (0, _emberSimpleAuthInitializersSetupSession['default'])(registry);

        (0, _chai.expect)(registry.injection).to.have.been.calledWith('session:main', 'store', 'session-store:test');
      });
    });

    (0, _mocha.describe)('when Ember.testing is false', function () {
      (0, _mocha.beforeEach)(function () {
        _ember['default'].testing = false;
      });

      (0, _mocha.afterEach)(function () {
        _ember['default'].testing = true;
      });

      (0, _emberMocha.it)('injects the application session store into the session', function () {
        _sinon['default'].spy(registry, 'injection');
        (0, _emberSimpleAuthInitializersSetupSession['default'])(registry);

        (0, _chai.expect)(registry.injection).to.have.been.calledWith('session:main', 'store', 'session-store:application');
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/initializers/setup-session-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/initializers/setup-session-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/initializers/setup-session-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/initializers/setup-session-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/initializers/setup-session-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/initializers/setup-session-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/instance-initializers/setup-session-restoration-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/instance-initializers/setup-session-restoration'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthInstanceInitializersSetupSessionRestoration) {

  (0, _mocha.describe)('setupSessionRestoration', function () {
    var container = undefined;
    var containerStub = undefined;
    var route = undefined;

    (0, _mocha.beforeEach)(function () {
      container = {
        lookup: function lookup() {}
      };

      var Route = _ember['default'].Route.extend();
      route = Route.create();

      containerStub = _sinon['default'].stub(container, 'lookup');
    });

    (0, _emberMocha.it)('adds a beforeModel method', function () {
      containerStub.withArgs('route:application').returns(route);
      (0, _emberSimpleAuthInstanceInitializersSetupSessionRestoration['default'])({ container: container });

      (0, _chai.expect)(route).to.respondTo('beforeModel');
    });

    (0, _mocha.describe)('the beforeModel method', function () {
      var session = undefined;

      (0, _mocha.beforeEach)(function () {
        session = {
          restore: function restore() {}
        };

        var Route = _ember['default'].Route.extend({
          beforeModel: function beforeModel() {
            return _ember['default'].RSVP.resolve('test');
          }
        });
        route = Route.create();

        containerStub.withArgs('route:application').returns(route);
        containerStub.withArgs('session:main').returns(session);
        (0, _emberSimpleAuthInstanceInitializersSetupSessionRestoration['default'])({ container: container });
      });

      (0, _mocha.describe)('when session restoration resolves', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(session, 'restore').returns(_ember['default'].RSVP.resolve());
        });

        (0, _emberMocha.it)('returns the return value of the original "beforeModel" method', function () {
          return route.beforeModel().then(function (value) {
            (0, _chai.expect)(value).to.eq('test');
          });
        });
      });

      (0, _mocha.describe)('when session restoration rejects', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(session, 'restore').returns(_ember['default'].RSVP.reject());
        });

        (0, _emberMocha.it)('returns the return value of the original "beforeModel" method', function () {
          return route.beforeModel().then(function (value) {
            (0, _chai.expect)(value).to.eq('test');
          });
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/instance-initializers/setup-session-restoration-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/instance-initializers/setup-session-restoration-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/instance-initializers/setup-session-restoration-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/instance-initializers/setup-session-restoration-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/instance-initializers/setup-session-restoration-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/instance-initializers/setup-session-restoration-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/internal-session-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/internal-session', 'ember-simple-auth/session-stores/ephemeral', 'ember-simple-auth/authenticators/base'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthInternalSession, _emberSimpleAuthSessionStoresEphemeral, _emberSimpleAuthAuthenticatorsBase) {

  (0, _mocha.describe)('InternalSession', function () {
    var session = undefined;
    var store = undefined;
    var authenticator = undefined;
    var container = undefined;

    (0, _mocha.beforeEach)(function () {
      container = { lookup: function lookup() {} };
      store = _emberSimpleAuthSessionStoresEphemeral['default'].create();
      authenticator = _emberSimpleAuthAuthenticatorsBase['default'].create();
      session = _emberSimpleAuthInternalSession['default'].create({ store: store, container: container });
      _sinon['default'].stub(container, 'lookup').withArgs('authenticator').returns(authenticator);
    });

    (0, _emberMocha.it)('does not allow data to be stored for the key "authenticated"', function () {
      (0, _chai.expect)(function () {
        session.set('authenticated', 'test');
      }).to['throw'](Error);
    });

    function itHandlesAuthenticatorEvents(preparation) {
      (0, _mocha.describe)('when the authenticator triggers the "sessionDataUpdated" event', function () {
        (0, _mocha.beforeEach)(function () {
          return preparation.call();
        });

        (0, _emberMocha.it)('stores the data the event is triggered with in its authenticated section', function (done) {
          authenticator.trigger('sessionDataUpdated', { some: 'property' });

          _ember['default'].run.next(function () {
            (0, _chai.expect)(session.get('authenticated')).to.eql({ some: 'property', authenticator: 'authenticator' });
            done();
          });
        });
      });

      (0, _mocha.describe)('when the authenticator triggers the "invalidated" event', function () {
        (0, _mocha.beforeEach)(function () {
          return preparation.call();
        });

        (0, _emberMocha.it)('is not authenticated', function (done) {
          authenticator.trigger('sessionDataInvalidated');

          _ember['default'].run.next(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
            done();
          });
        });

        (0, _emberMocha.it)('clears its authenticated section', function (done) {
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });
          authenticator.trigger('sessionDataInvalidated');

          _ember['default'].run.next(function () {
            (0, _chai.expect)(session.get('content')).to.eql({ some: 'property', authenticated: {} });
            done();
          });
        });

        (0, _emberMocha.it)('updates the store', function (done) {
          authenticator.trigger('sessionDataInvalidated');

          _ember['default'].run.next(function () {
            store.restore().then(function (properties) {
              (0, _chai.expect)(properties.authenticated).to.eql({});
              done();
            });
          });
        });

        (0, _emberMocha.it)('triggers the "invalidationSucceeded" event', function (done) {
          var triggered = false;
          session.one('invalidationSucceeded', function () {
            triggered = true;
          });
          authenticator.trigger('sessionDataInvalidated');

          _ember['default'].run.next(function () {
            (0, _chai.expect)(triggered).to.be['true'];
            done();
          });
        });
      });
    }

    (0, _mocha.describe)('restore', function () {
      function itDoesNotRestore() {
        (0, _emberMocha.it)('returns a rejecting promise', function () {
          return session.restore()['catch'](function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });

        (0, _emberMocha.it)('is not authenticated', function () {
          return session.restore()['catch'](function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });

        (0, _emberMocha.it)('clears its authenticated section', function () {
          store.persist({ some: 'property', authenticated: { some: 'other property' } });

          return session.restore()['catch'](function () {
            (0, _chai.expect)(session.get('content')).to.eql({ some: 'property', authenticated: {} });
          });
        });
      }

      (0, _mocha.describe)('when the restored data contains an authenticator factory', function () {
        (0, _mocha.beforeEach)(function () {
          store.persist({ authenticated: { authenticator: 'authenticator' } });
        });

        (0, _mocha.describe)('when the authenticator resolves restoration', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(authenticator, 'restore').returns(_ember['default'].RSVP.resolve({ some: 'property' }));
          });

          (0, _emberMocha.it)('returns a resolving promise', function () {
            return session.restore().then(function () {
              (0, _chai.expect)(true).to.be['true'];
            });
          });

          (0, _emberMocha.it)('is authenticated', function () {
            return session.restore().then(function () {
              (0, _chai.expect)(session.get('isAuthenticated')).to.be['true'];
            });
          });

          (0, _emberMocha.it)('stores the data the authenticator resolves with in its authenticated section', function () {
            return store.persist({ authenticated: { authenticator: 'authenticator' } }).then(function () {
              return session.restore().then(function () {
                return store.restore().then(function (properties) {
                  delete properties.authenticator;

                  (0, _chai.expect)(session.get('authenticated')).to.eql({ some: 'property', authenticator: 'authenticator' });
                });
              });
            });
          });

          (0, _emberMocha.it)('persists its content in the store', function () {
            return store.persist({ authenticated: { authenticator: 'authenticator' }, someOther: 'property' }).then(function () {
              return session.restore().then(function () {
                return store.restore().then(function (properties) {
                  delete properties.authenticator;

                  (0, _chai.expect)(properties).to.eql({ authenticated: { some: 'property', authenticator: 'authenticator' }, someOther: 'property' });
                });
              });
            });
          });

          (0, _emberMocha.it)('persists the authenticator factory in the store', function () {
            return session.restore().then(function () {
              return store.restore().then(function (properties) {
                (0, _chai.expect)(properties.authenticated.authenticator).to.eql('authenticator');
              });
            });
          });

          (0, _emberMocha.it)('does not trigger the "authenticationSucceeded" event', function () {
            var triggered = false;
            session.one('authenticationSucceeded', function () {
              return triggered = true;
            });

            return session.restore().then(function () {
              (0, _chai.expect)(triggered).to.be['false'];
            });
          });

          itHandlesAuthenticatorEvents(function () {
            return session.restore();
          });
        });

        (0, _mocha.describe)('when the authenticator rejects restoration', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(authenticator, 'restore').returns(_ember['default'].RSVP.reject());
          });

          itDoesNotRestore();
        });
      });

      (0, _mocha.describe)('when the restored data does not contain an authenticator factory', function () {
        itDoesNotRestore();
      });

      (0, _mocha.describe)('when the store rejects restoration', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(store, 'restore').returns(_ember['default'].RSVP.Promise.reject());
        });

        (0, _emberMocha.it)('is not authenticated', function () {
          return session.restore().then(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });
      });

      (0, _mocha.describe)('when the store rejects persistance', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(store, 'persist').returns(_ember['default'].RSVP.reject());
        });

        (0, _emberMocha.it)('is not authenticated', function () {
          return session.restore().then(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });
      });

      (0, _mocha.describe)('with older synchronous stores (< v1.1.0)', function () {
        (0, _mocha.describe)('when restoring the session', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(store, 'persist').returns();
            _sinon['default'].stub(store, 'clear').returns();
          });

          (0, _mocha.describe)('when the store resolves restoration', function () {
            (0, _mocha.beforeEach)(function () {
              _sinon['default'].stub(store, 'restore').returns({ authenticated: { authenticator: 'authenticator' } });
            });

            (0, _emberMocha.it)('is authenticated', function () {
              return session.restore().then(function () {
                (0, _chai.expect)(session.get('isAuthenticated')).to.be['true'];
              });
            });
          });

          (0, _mocha.describe)('when the store rejects restoration', function () {
            (0, _mocha.beforeEach)(function () {
              _sinon['default'].stub(store, 'restore').returns({});
            });

            (0, _emberMocha.it)('is not authenticated', function () {
              return session.restore().then(function () {
                (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
              });
            });
          });
        });
      });
    });

    (0, _mocha.describe)('authentication', function () {
      (0, _mocha.describe)('when the authenticator resolves authentication', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.resolve({ some: 'property' }));
        });

        (0, _emberMocha.it)('is authenticated', function () {
          return session.authenticate('authenticator').then(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['true'];
          });
        });

        (0, _emberMocha.it)('returns a resolving promise', function () {
          return session.authenticate('authenticator').then(function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });

        (0, _emberMocha.it)('stores the data the authenticator resolves with in its authenticated section', function () {
          return session.authenticate('authenticator').then(function () {
            (0, _chai.expect)(session.get('authenticated')).to.eql({ some: 'property', authenticator: 'authenticator' });
          });
        });

        (0, _emberMocha.it)('persists its content in the store', function () {
          return session.authenticate('authenticator').then(function () {
            return store.restore().then(function (properties) {
              delete properties.authenticator;

              (0, _chai.expect)(properties).to.eql({ authenticated: { some: 'property', authenticator: 'authenticator' } });
            });
          });
        });

        (0, _emberMocha.it)('persists the authenticator factory in the store', function () {
          return session.authenticate('authenticator').then(function () {
            return store.restore().then(function (properties) {
              (0, _chai.expect)(properties.authenticated.authenticator).to.eql('authenticator');
            });
          });
        });

        (0, _emberMocha.it)('triggers the "authenticationSucceeded" event', function () {
          var triggered = false;
          session.one('authenticationSucceeded', function () {
            return triggered = true;
          });

          return session.authenticate('authenticator').then(function () {
            (0, _chai.expect)(triggered).to.be['true'];
          });
        });

        itHandlesAuthenticatorEvents(function () {
          return session.authenticate('authenticator');
        });
      });

      (0, _mocha.describe)('when the authenticator rejects authentication', function () {
        (0, _emberMocha.it)('is not authenticated', function () {
          _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.reject('error auth'));

          return session.authenticate('authenticator')['catch'](function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });

        (0, _emberMocha.it)('returns a rejecting promise', function () {
          _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.reject('error auth'));

          return session.authenticate('authenticator')['catch'](function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });

        (0, _emberMocha.it)('clears its authenticated section', function () {
          _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.reject('error auth'));
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });

          return session.authenticate('authenticator')['catch'](function () {
            (0, _chai.expect)(session.get('content')).to.eql({ some: 'property', authenticated: {} });
          });
        });

        (0, _emberMocha.it)('updates the store', function () {
          _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.reject('error auth'));
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });

          return session.authenticate('authenticator')['catch'](function () {
            return store.restore().then(function (properties) {
              (0, _chai.expect)(properties).to.eql({ some: 'property', authenticated: {} });
            });
          });
        });

        (0, _emberMocha.it)('does not trigger the "authenticationSucceeded" event', function () {
          var triggered = false;
          _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.reject('error auth'));
          session.one('authenticationSucceeded', function () {
            return triggered = true;
          });

          return session.authenticate('authenticator')['catch'](function () {
            (0, _chai.expect)(triggered).to.be['false'];
          });
        });
      });

      (0, _mocha.describe)('when the store rejects persistance', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(store, 'persist').returns(_ember['default'].RSVP.reject());
        });

        (0, _emberMocha.it)('is not authenticated', function () {
          return session.authenticate('authenticator').then(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });
      });
    });

    (0, _mocha.describe)('invalidation', function () {
      (0, _mocha.beforeEach)(function () {
        _sinon['default'].stub(authenticator, 'authenticate').returns(_ember['default'].RSVP.resolve({ some: 'property' }));
        return session.authenticate('authenticator');
      });

      (0, _mocha.describe)('when the authenticator resolves invaldiation', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(authenticator, 'invalidate').returns(_ember['default'].RSVP.resolve());
        });

        (0, _emberMocha.it)('is not authenticated', function () {
          return session.invalidate().then(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });

        (0, _emberMocha.it)('returns a resolving promise', function () {
          return session.invalidate().then(function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });

        (0, _emberMocha.it)('clears its authenticated section', function () {
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });

          return session.invalidate().then(function () {
            (0, _chai.expect)(session.get('content')).to.eql({ some: 'property', authenticated: {} });
          });
        });

        (0, _emberMocha.it)('updates the store', function () {
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });

          return session.invalidate().then(function () {
            return store.restore().then(function (properties) {
              (0, _chai.expect)(properties).to.eql({ some: 'property', authenticated: {} });
            });
          });
        });

        (0, _emberMocha.it)('triggers the "invalidationSucceeded" event', function () {
          var triggered = false;
          session.one('invalidationSucceeded', function () {
            return triggered = true;
          });

          return session.invalidate().then(function () {
            (0, _chai.expect)(triggered).to.be['true'];
          });
        });
      });

      (0, _mocha.describe)('when the authenticator rejects invalidation', function () {
        (0, _emberMocha.it)('stays authenticated', function () {
          _sinon['default'].stub(authenticator, 'invalidate').returns(_ember['default'].RSVP.reject('error'));

          return session.invalidate()['catch'](function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['true'];
          });
        });

        (0, _emberMocha.it)('returns a rejecting promise', function () {
          _sinon['default'].stub(authenticator, 'invalidate').returns(_ember['default'].RSVP.reject('error'));

          return session.invalidate()['catch'](function () {
            (0, _chai.expect)(true).to.be['true'];
          });
        });

        (0, _emberMocha.it)('keeps its content', function () {
          _sinon['default'].stub(authenticator, 'invalidate').returns(_ember['default'].RSVP.reject('error'));

          return session.invalidate()['catch'](function () {
            (0, _chai.expect)(session.get('authenticated')).to.eql({ some: 'property', authenticator: 'authenticator' });
          });
        });

        (0, _emberMocha.it)('does not update the store', function () {
          _sinon['default'].stub(authenticator, 'invalidate').returns(_ember['default'].RSVP.reject('error'));

          return session.invalidate()['catch'](function () {
            return store.restore().then(function (properties) {
              (0, _chai.expect)(properties).to.eql({ authenticated: { some: 'property', authenticator: 'authenticator' } });
            });
          });
        });

        (0, _emberMocha.it)('does not trigger the "invalidationSucceeded" event', function () {
          _sinon['default'].stub(authenticator, 'invalidate').returns(_ember['default'].RSVP.reject('error'));
          var triggered = false;
          session.one('invalidationSucceeded', function () {
            return triggered = true;
          });

          return session.invalidate()['catch'](function () {
            (0, _chai.expect)(triggered).to.be['false'];
          });
        });

        itHandlesAuthenticatorEvents(_ember['default'].K);
      });

      (0, _mocha.describe)('when the store rejects persistance', function () {
        (0, _mocha.beforeEach)(function () {
          _sinon['default'].stub(store, 'persist').returns(_ember['default'].RSVP.reject());
        });

        (0, _emberMocha.it)('rejects but is not authenticated', function () {
          return session.invalidate()['catch'](function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
          });
        });
      });
    });

    (0, _mocha.describe)("when the session's content changes", function () {
      (0, _mocha.describe)('when a single property is set', function () {
        (0, _mocha.beforeEach)(function () {
          session.set('some', 'property');
        });

        (0, _emberMocha.it)('persists its content in the store', function () {
          return store.restore().then(function (properties) {
            delete properties.authenticator;

            (0, _chai.expect)(properties).to.eql({ some: 'property', authenticated: {} });
          });
        });
      });

      (0, _mocha.describe)('when multiple properties are set at once', function () {
        (0, _mocha.beforeEach)(function () {
          session.set('some', 'property');
          session.setProperties({ multiple: 'properties' });
        });

        (0, _emberMocha.it)('persists its content in the store', function () {
          return store.restore().then(function (properties) {
            delete properties.authenticator;

            (0, _chai.expect)(properties).to.eql({ some: 'property', multiple: 'properties', authenticated: {} });
          });
        });
      });
    });

    (0, _mocha.describe)('when the store triggers the "sessionDataUpdated" event', function () {
      (0, _mocha.describe)('when there is an authenticator factory in the event data', function () {
        (0, _mocha.describe)('when the authenticator resolves restoration', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(authenticator, 'restore').returns(_ember['default'].RSVP.resolve({ some: 'other property' }));
          });

          (0, _emberMocha.it)('is authenticated', function (done) {
            store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(session.get('isAuthenticated')).to.be['true'];
              done();
            });
          });

          (0, _emberMocha.it)('stores the data the authenticator resolves with in its authenticated section', function (done) {
            store.trigger('sessionDataUpdated', { some: 'property', authenticated: { authenticator: 'authenticator' } });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(session.get('authenticated')).to.eql({ some: 'other property', authenticator: 'authenticator' });
              done();
            });
          });

          (0, _emberMocha.it)('persists its content in the store', function (done) {
            store.trigger('sessionDataUpdated', { some: 'property', authenticated: { authenticator: 'authenticator' } });

            _ember['default'].run.next(function () {
              store.restore().then(function (properties) {

                (0, _chai.expect)(properties).to.eql({ some: 'property', authenticated: { some: 'other property', authenticator: 'authenticator' } });
                done();
              });
            });
          });

          (0, _mocha.describe)('when the session is already authenticated', function () {
            (0, _mocha.beforeEach)(function () {
              session.set('isAuthenticated', true);
            });

            (0, _emberMocha.it)('does not trigger the "authenticationSucceeded" event', function (done) {
              var triggered = false;
              session.one('authenticationSucceeded', function () {
                return triggered = true;
              });
              store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

              _ember['default'].run.next(function () {
                (0, _chai.expect)(triggered).to.be['false'];
                done();
              });
            });
          });

          (0, _mocha.describe)('when the session is not already authenticated', function () {
            (0, _mocha.beforeEach)(function () {
              session.set('isAuthenticated', false);
            });

            (0, _emberMocha.it)('triggers the "authenticationSucceeded" event', function (done) {
              var triggered = false;
              session.one('authenticationSucceeded', function () {
                return triggered = true;
              });
              store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

              _ember['default'].run.next(function () {
                (0, _chai.expect)(triggered).to.be['true'];
                done();
              });
            });
          });
        });

        (0, _mocha.describe)('when the authenticator rejects restoration', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(authenticator, 'restore').returns(_ember['default'].RSVP.reject());
          });

          (0, _emberMocha.it)('is not authenticated', function (done) {
            store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
              done();
            });
          });

          (0, _emberMocha.it)('clears its authenticated section', function (done) {
            session.set('content', { some: 'property', authenticated: { some: 'other property' } });
            store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(session.get('content')).to.eql({ some: 'other property', authenticated: {} });
              done();
            });
          });

          (0, _emberMocha.it)('updates the store', function (done) {
            session.set('content', { some: 'property', authenticated: { some: 'other property' } });
            store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

            _ember['default'].run.next(function () {
              store.restore().then(function (properties) {
                (0, _chai.expect)(properties).to.eql({ some: 'other property', authenticated: {} });
                done();
              });
            });
          });

          (0, _mocha.describe)('when the session is authenticated', function () {
            (0, _mocha.beforeEach)(function () {
              session.set('isAuthenticated', true);
            });

            (0, _emberMocha.it)('triggers the "invalidationSucceeded" event', function (done) {
              var triggered = false;
              session.one('invalidationSucceeded', function () {
                return triggered = true;
              });
              store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

              _ember['default'].run.next(function () {
                (0, _chai.expect)(triggered).to.be['true'];
                done();
              });
            });
          });

          (0, _mocha.describe)('when the session is not authenticated', function () {
            (0, _mocha.beforeEach)(function () {
              session.set('isAuthenticated', false);
            });

            (0, _emberMocha.it)('does not trigger the "invalidationSucceeded" event', function (done) {
              var triggered = false;
              session.one('invalidationSucceeded', function () {
                return triggered = true;
              });
              store.trigger('sessionDataUpdated', { some: 'other property', authenticated: { authenticator: 'authenticator' } });

              _ember['default'].run.next(function () {
                (0, _chai.expect)(triggered).to.be['false'];
                done();
              });
            });
          });
        });
      });

      (0, _mocha.describe)('when there is no authenticator factory in the store', function () {
        (0, _emberMocha.it)('is not authenticated', function (done) {
          store.trigger('sessionDataUpdated', { some: 'other property' });

          _ember['default'].run.next(function () {
            (0, _chai.expect)(session.get('isAuthenticated')).to.be['false'];
            done();
          });
        });

        (0, _emberMocha.it)('clears its authenticated section', function (done) {
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });
          store.trigger('sessionDataUpdated', { some: 'other property' });

          _ember['default'].run.next(function () {
            (0, _chai.expect)(session.get('content')).to.eql({ some: 'other property', authenticated: {} });
            done();
          });
        });

        (0, _emberMocha.it)('updates the store', function (done) {
          session.set('content', { some: 'property', authenticated: { some: 'other property' } });
          store.trigger('sessionDataUpdated', { some: 'other property' });

          _ember['default'].run.next(function () {
            store.restore().then(function (properties) {
              (0, _chai.expect)(properties).to.eql({ some: 'other property', authenticated: {} });
              done();
            });
          });
        });

        (0, _mocha.describe)('when the session is authenticated', function () {
          (0, _mocha.beforeEach)(function () {
            session.set('isAuthenticated', true);
          });

          (0, _emberMocha.it)('triggers the "invalidationSucceeded" event', function (done) {
            var triggered = false;
            session.one('invalidationSucceeded', function () {
              return triggered = true;
            });
            store.trigger('sessionDataUpdated', { some: 'other property' });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(triggered).to.be['true'];
              done();
            });
          });
        });

        (0, _mocha.describe)('when the session is not authenticated', function () {
          (0, _mocha.beforeEach)(function () {
            session.set('isAuthenticated', false);
          });

          (0, _emberMocha.it)('does not trigger the "invalidationSucceeded" event', function (done) {
            var triggered = false;
            session.one('invalidationSucceeded', function () {
              return triggered = true;
            });
            store.trigger('sessionDataUpdated', { some: 'other property' });

            _ember['default'].run.next(function () {
              (0, _chai.expect)(triggered).to.be['false'];
              done();
            });
          });
        });
      });
    });

    (0, _emberMocha.it)('does not share the content object between multiple instances', function () {
      var session2 = _emberSimpleAuthInternalSession['default'].create({ store: store, container: container });

      (0, _chai.expect)(session2.get('content')).to.not.equal(session.get('content'));
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/internal-session-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/internal-session-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/internal-session-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/internal-session-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/internal-session-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/internal-session-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/application-route-mixin-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/mixins/application-route-mixin', 'ember-simple-auth/internal-session', 'ember-simple-auth/session-stores/ephemeral', 'ember-simple-auth/configuration'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthMixinsApplicationRouteMixin, _emberSimpleAuthInternalSession, _emberSimpleAuthSessionStoresEphemeral, _emberSimpleAuthConfiguration) {

  (0, _mocha.describe)('ApplicationRouteMixin', function () {
    var session = undefined;
    var route = undefined;

    (0, _mocha.beforeEach)(function () {
      session = _emberSimpleAuthInternalSession['default'].create({ store: _emberSimpleAuthSessionStoresEphemeral['default'].create() });

      route = _ember['default'].Route.extend(_emberSimpleAuthMixinsApplicationRouteMixin['default'], {
        transitionTo: function transitionTo() {}
      }).create({
        session: session
      });
    });

    (0, _mocha.describe)('mapping of service events to route methods', function () {
      (0, _mocha.beforeEach)(function () {
        _sinon['default'].spy(route, 'sessionAuthenticated');
        _sinon['default'].spy(route, 'sessionInvalidated');
      });

      (0, _emberMocha.it)("maps the services's 'authenticationSucceeded' event into a method call", function (done) {
        session.trigger('authenticationSucceeded');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(route.sessionAuthenticated).to.have.been.calledOnce;
          done();
        });
      });

      (0, _emberMocha.it)("maps the services's 'invalidationSucceeded' event into a method call", function (done) {
        session.trigger('invalidationSucceeded');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(route.sessionInvalidated).to.have.been.calledOnce;
          done();
        });
      });

      (0, _emberMocha.it)('does not attach the event listeners twice', function (done) {
        route.beforeModel();
        session.trigger('authenticationSucceeded');

        _ember['default'].run.next(function () {
          (0, _chai.expect)(route.sessionAuthenticated).to.have.been.calledOnce;
          done();
        });
      });
    });

    (0, _mocha.describe)('sessionAuthenticated', function () {
      (0, _mocha.beforeEach)(function () {
        _sinon['default'].spy(route, 'transitionTo');
      });

      (0, _mocha.describe)('when an attempted transition is stored in the session', function () {
        var attemptedTransition = undefined;

        (0, _mocha.beforeEach)(function () {
          attemptedTransition = {
            retry: function retry() {}
          };
          session.set('attemptedTransition', attemptedTransition);
        });

        (0, _emberMocha.it)('retries that transition', function () {
          _sinon['default'].spy(attemptedTransition, 'retry');
          route.sessionAuthenticated();

          (0, _chai.expect)(attemptedTransition.retry).to.have.been.calledOnce;
        });

        (0, _emberMocha.it)('removes it from the session', function () {
          route.sessionAuthenticated();

          (0, _chai.expect)(session.get('attemptedTransition')).to.be['null'];
        });
      });

      (0, _mocha.describe)('when no attempted transition is stored in the session', function () {
        (0, _emberMocha.it)('transitions to "Configuration.routeAfterAuthentication"', function () {
          route.sessionAuthenticated();

          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith(_emberSimpleAuthConfiguration['default'].routeAfterAuthentication);
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/mixins/application-route-mixin-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/mixins/application-route-mixin-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/mixins/application-route-mixin-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/application-route-mixin-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/mixins/application-route-mixin-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/mixins/application-route-mixin-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/authenticated-route-mixin-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/mixins/authenticated-route-mixin', 'ember-simple-auth/internal-session', 'ember-simple-auth/configuration', 'ember-simple-auth/session-stores/ephemeral'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthMixinsAuthenticatedRouteMixin, _emberSimpleAuthInternalSession, _emberSimpleAuthConfiguration, _emberSimpleAuthSessionStoresEphemeral) {

  (0, _mocha.describe)('AuthenticatedRouteMixin', function () {
    var route = undefined;
    var session = undefined;
    var transition = undefined;

    (0, _mocha.describe)('#beforeModel', function () {
      (0, _mocha.beforeEach)(function () {
        var MixinImplementingBeforeModel = _ember['default'].Mixin.create({
          beforeModel: function beforeModel() {
            return _ember['default'].RSVP.resolve('upstreamReturnValue');
          }
        });
        var Route = _ember['default'].Route.extend(MixinImplementingBeforeModel, _emberSimpleAuthMixinsAuthenticatedRouteMixin['default'], {
          // replace actual transitionTo as the router isn't set up etc.
          transitionTo: function transitionTo() {}
        });

        session = _emberSimpleAuthInternalSession['default'].create({ store: _emberSimpleAuthSessionStoresEphemeral['default'].create() });
        transition = {
          abort: function abort() {},
          send: function send() {}
        };

        route = Route.create({ session: session });
        _sinon['default'].spy(transition, 'abort');
        _sinon['default'].spy(transition, 'send');
        _sinon['default'].spy(route, 'transitionTo');
      });

      (0, _mocha.describe)('if the session is authenticated', function () {
        (0, _mocha.beforeEach)(function () {
          session.set('isAuthenticated', true);
        });

        (0, _emberMocha.it)('returns the upstream promise', function () {
          return route.beforeModel(transition).then(function (result) {
            (0, _chai.expect)(result).to.equal('upstreamReturnValue');
          });
        });

        (0, _emberMocha.it)('does not abort the transition', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(transition.abort).to.not.have.been.called;
        });

        (0, _emberMocha.it)('does not transition to the authentication route', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(route.transitionTo).to.not.have.been.calledWith(_emberSimpleAuthConfiguration['default'].authenticationRoute);
        });
      });

      (0, _mocha.describe)('if the session is not authenticated', function () {
        (0, _emberMocha.it)('does not return the upstream promise', function () {
          (0, _chai.expect)(route.beforeModel(transition)).to.be.undefined;
        });

        (0, _emberMocha.it)('aborts the transition', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(transition.abort).to.have.been.called;
        });

        (0, _emberMocha.it)('transitions to the authentication route', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith(_emberSimpleAuthConfiguration['default'].authenticationRoute);
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/mixins/authenticated-route-mixin-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/mixins/authenticated-route-mixin-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/mixins/authenticated-route-mixin-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/authenticated-route-mixin-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/mixins/authenticated-route-mixin-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/mixins/authenticated-route-mixin-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/data-adapter-mixin-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/mixins/data-adapter-mixin'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthMixinsDataAdapterMixin) {

  (0, _mocha.describe)('DataAdapterMixin', function () {
    var adapter = undefined;
    var sessionService = undefined;
    var hash = undefined;

    (0, _mocha.beforeEach)(function () {
      hash = {};
      sessionService = _ember['default'].Object.create({
        authorize: function authorize() {},
        invalidate: function invalidate() {}
      });

      var BaseAdapter = _ember['default'].Object.extend({
        ajaxOptions: function ajaxOptions() {
          return hash;
        },
        handleResponse: function handleResponse() {
          return '_super return value';
        }
      });
      var Adapter = BaseAdapter.extend(_emberSimpleAuthMixinsDataAdapterMixin['default'], {
        authorizer: 'authorizer:some'
      });
      adapter = Adapter.create({ session: sessionService });
    });

    (0, _mocha.describe)('#ajaxOptions', function () {
      (0, _emberMocha.it)('registers a beforeSend hook', function () {
        adapter.ajaxOptions();

        (0, _chai.expect)(hash).to.have.ownProperty('beforeSend');
      });

      (0, _emberMocha.it)('asserts the presence of authorizer', function () {
        adapter.set('authorizer', null);
        (0, _chai.expect)(function () {
          adapter.ajaxOptions();
        }).to['throw'](/Assertion Failed/);
      });

      (0, _emberMocha.it)('preserves an existing beforeSend hook', function () {
        var existingBeforeSend = _sinon['default'].spy();
        hash.beforeSend = existingBeforeSend;
        adapter.ajaxOptions();
        hash.beforeSend();

        (0, _chai.expect)(existingBeforeSend).to.have.been.called;
      });

      (0, _emberMocha.it)('authorizes with the given authorizer', function () {
        _sinon['default'].spy(sessionService, 'authorize');
        adapter.ajaxOptions();
        hash.beforeSend();

        (0, _chai.expect)(sessionService.authorize).to.have.been.calledWith('authorizer:some');
      });

      (0, _mocha.describe)('the beforeSend hook', function () {
        var xhr = undefined;

        (0, _mocha.beforeEach)(function () {
          adapter.ajaxOptions();
          xhr = {
            setRequestHeader: function setRequestHeader() {}
          };
          _sinon['default'].spy(xhr, 'setRequestHeader');
        });

        (0, _mocha.describe)('when the authorizer calls the block', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(sessionService, 'authorize', function (authorizer, block) {
              block('header', 'value');
            });
            hash.beforeSend(xhr);
          });

          (0, _emberMocha.it)('adds a request header as given by the authorizer', function () {
            (0, _chai.expect)(xhr.setRequestHeader).to.have.been.calledWith('header', 'value');
          });
        });

        (0, _mocha.describe)('when the authorizer does not call the block', function () {
          (0, _mocha.beforeEach)(function () {
            _sinon['default'].stub(sessionService, 'authorize');
            hash.beforeSend(xhr);
          });

          (0, _emberMocha.it)('does not add a request header', function () {
            (0, _chai.expect)(xhr.setRequestHeader).to.not.have.been.called;
          });
        });
      });
    });

    (0, _mocha.describe)('#handleResponse', function () {
      (0, _mocha.beforeEach)(function () {
        _sinon['default'].spy(sessionService, 'invalidate');
      });

      (0, _mocha.describe)('when the response status is 401', function () {
        (0, _mocha.describe)('when the session is authenticated', function () {
          (0, _mocha.beforeEach)(function () {
            sessionService.set('isAuthenticated', true);
          });

          (0, _emberMocha.it)('invalidates the session', function () {
            adapter.handleResponse(401);

            (0, _chai.expect)(sessionService.invalidate).to.have.been.calledOnce;
          });
        });

        (0, _mocha.describe)('when the session is not authenticated', function () {
          (0, _mocha.beforeEach)(function () {
            sessionService.set('isAuthenticated', false);
          });

          (0, _emberMocha.it)('does not invalidate the session', function () {
            adapter.handleResponse(401);

            (0, _chai.expect)(sessionService.invalidate).to.not.have.been.called;
          });
        });
      });

      (0, _mocha.describe)('when the response status is not 401', function () {
        (0, _emberMocha.it)('does not invalidate the session', function () {
          adapter.handleResponse(200);

          (0, _chai.expect)(sessionService.invalidate).to.not.have.been.called;
        });
      });

      (0, _emberMocha.it)("returns _super's return value", function () {
        (0, _chai.expect)(adapter.handleResponse(401)).to.eq('_super return value');
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/mixins/data-adapter-mixin-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/mixins/data-adapter-mixin-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/mixins/data-adapter-mixin-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/data-adapter-mixin-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/mixins/data-adapter-mixin-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/mixins/data-adapter-mixin-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/unauthenticated-route-mixin-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/mixins/unauthenticated-route-mixin', 'ember-simple-auth/internal-session', 'ember-simple-auth/configuration', 'ember-simple-auth/session-stores/ephemeral'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthMixinsUnauthenticatedRouteMixin, _emberSimpleAuthInternalSession, _emberSimpleAuthConfiguration, _emberSimpleAuthSessionStoresEphemeral) {

  (0, _mocha.describe)('UnauthenticatedRouteMixin', function () {
    var route = undefined;
    var session = undefined;
    var transition = undefined;

    (0, _mocha.describe)('#beforeModel', function () {
      (0, _mocha.beforeEach)(function () {
        var MixinImplementingBeforeModel = _ember['default'].Mixin.create({
          beforeModel: function beforeModel() {
            return _ember['default'].RSVP.resolve('upstreamReturnValue');
          }
        });
        var Route = _ember['default'].Route.extend(MixinImplementingBeforeModel, _emberSimpleAuthMixinsUnauthenticatedRouteMixin['default'], {
          // replace actual transitionTo as the router isn't set up etc.
          transitionTo: function transitionTo() {}
        });

        session = _emberSimpleAuthInternalSession['default'].create({ store: _emberSimpleAuthSessionStoresEphemeral['default'].create() });
        transition = {
          abort: function abort() {},
          send: function send() {}
        };

        route = Route.create({ session: session });
        _sinon['default'].spy(transition, 'abort');
        _sinon['default'].spy(route, 'transitionTo');
      });

      (0, _mocha.describe)('if the session is authenticated', function () {
        (0, _mocha.beforeEach)(function () {
          session.set('isAuthenticated', true);
        });

        (0, _emberMocha.it)('aborts the transition', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(transition.abort).to.have.been.called;
        });

        (0, _emberMocha.it)('transitions to routeIfAlreadyAuthenticated', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(route.transitionTo).to.have.been.calledWith(_emberSimpleAuthConfiguration['default'].routeIfAlreadyAuthenticated);
        });

        (0, _emberMocha.it)('does not return the upstream promise', function () {
          (0, _chai.expect)(route.beforeModel(transition)).to.be.undefined;
        });
      });

      (0, _mocha.describe)('if the session is not authenticated', function () {
        (0, _emberMocha.it)('does not abort the transition', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(transition.abort).to.not.have.been.called;
        });

        (0, _emberMocha.it)('does not call route transitionTo', function () {
          route.beforeModel(transition);

          (0, _chai.expect)(route.transitionTo).to.not.have.been.called;
        });

        (0, _emberMocha.it)('returns the upstream promise', function () {
          return route.beforeModel(transition).then(function (result) {
            (0, _chai.expect)(result).to.equal('upstreamReturnValue');
          });
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/mixins/unauthenticated-route-mixin-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/mixins/unauthenticated-route-mixin-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/mixins/unauthenticated-route-mixin-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/mixins/unauthenticated-route-mixin-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/mixins/unauthenticated-route-mixin-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/mixins/unauthenticated-route-mixin-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/routes/application-test', ['exports', 'chai', 'ember-mocha'], function (exports, _chai, _emberMocha) {

  (0, _emberMocha.describeModule)('route:application', 'ApplicationRoute', {
    needs: ['service:session', 'router:main']
  }, function () {
    (0, _emberMocha.it)('is still testable when using the ApplicationRouteMixin', function () {
      var route = this.subject();

      (0, _chai.expect)(route).to.be.ok;
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/routes/application-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/routes/application-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/routes/application-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/routes/application-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/routes/application-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/routes/application-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/routes/login-test', ['exports', 'chai', 'ember-mocha'], function (exports, _chai, _emberMocha) {

  (0, _emberMocha.describeModule)('route:login', 'LoginRoute', {
    needs: ['router:main']
  }, function () {
    (0, _emberMocha.it)('is still testable when using the UnauthenticatedRouteMixin', function () {
      var route = this.subject();

      (0, _chai.expect)(route).to.be.ok;
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/routes/login-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/routes/login-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/routes/login-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/routes/login-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/routes/login-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/routes/login-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/routes/protected-test', ['exports', 'chai', 'ember-mocha'], function (exports, _chai, _emberMocha) {

  (0, _emberMocha.describeModule)('route:protected', 'ProtectedRoute', {
    needs: ['router:main']
  }, function () {
    (0, _emberMocha.it)('is still testable when using the AuthenticatedRouteMixin', function () {
      var route = this.subject();

      (0, _chai.expect)(route).to.be.ok;
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/routes/protected-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/routes/protected-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/routes/protected-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/routes/protected-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/routes/protected-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/routes/protected-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/services/session-test', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'ember-simple-auth/services/session'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _emberSimpleAuthServicesSession) {

  (0, _mocha.describe)('SessionService', function () {
    var sessionService = undefined;
    var session = undefined;
    var authorizer = undefined;

    (0, _mocha.beforeEach)(function () {
      session = _ember['default'].ObjectProxy.extend(_ember['default'].Evented, {
        content: {}
      }).create();
      authorizer = {
        authorize: function authorize() {}
      };
      var container = { lookup: function lookup() {} };
      _sinon['default'].stub(container, 'lookup').withArgs('authorizer').returns(authorizer);
      sessionService = _emberSimpleAuthServicesSession['default'].create({ container: container, session: session });
    });

    (0, _emberMocha.it)('forwards the "authenticationSucceeded" event from the session', function (done) {
      var triggered = false;
      sessionService.one('authenticationSucceeded', function () {
        return triggered = true;
      });
      session.trigger('authenticationSucceeded');

      _ember['default'].run.next(function () {
        (0, _chai.expect)(triggered).to.be['true'];
        done();
      });
    });

    (0, _emberMocha.it)('forwards the "invalidationSucceeded" event from the session', function (done) {
      var triggered = false;
      sessionService.one('invalidationSucceeded', function () {
        return triggered = true;
      });
      session.trigger('invalidationSucceeded');

      _ember['default'].run.next(function () {
        (0, _chai.expect)(triggered).to.be['true'];
        done();
      });
    });

    (0, _mocha.describe)('isAuthenticated', function () {
      (0, _emberMocha.it)('is read from the session', function () {
        session.set('isAuthenticated', true);

        (0, _chai.expect)(sessionService.get('isAuthenticated')).to.be['true'];
      });

      (0, _emberMocha.it)('is read-only', function () {
        (0, _chai.expect)(function () {
          sessionService.set('isAuthenticated', false);
        }).to['throw'];
      });
    });

    (0, _mocha.describe)('store', function () {
      (0, _emberMocha.it)('is read from the session', function () {
        session.set('store', 'some store');

        (0, _chai.expect)(sessionService.get('store')).to.eq('some store');
      });

      (0, _emberMocha.it)('is read-only', function () {
        (0, _chai.expect)(function () {
          sessionService.set('store', 'some other store');
        }).to['throw'];
      });
    });

    (0, _mocha.describe)('attemptedTransition', function () {
      (0, _emberMocha.it)('is read from the session', function () {
        session.set('attemptedTransition', 'some transition');

        (0, _chai.expect)(sessionService.get('attemptedTransition')).to.eq('some transition');
      });

      (0, _emberMocha.it)('is written back to the session', function () {
        sessionService.set('attemptedTransition', 'some other transition');

        (0, _chai.expect)(session.get('attemptedTransition')).to.eq('some other transition');
      });
    });

    (0, _mocha.describe)('data', function () {
      (0, _emberMocha.it)("is read from the session's content", function () {
        session.set('some', 'data');

        (0, _chai.expect)(sessionService.get('data')).to.eql({ some: 'data' });
      });

      (0, _emberMocha.it)("is written back to the session's content", function () {
        sessionService.set('data.some', { other: 'data' });

        (0, _chai.expect)(session.content).to.eql({ some: { other: 'data' } });
      });

      (0, _emberMocha.it)('is read-only', function () {
        (0, _chai.expect)(function () {
          sessionService.set('data', false);
        }).to['throw'];
      });
    });

    (0, _mocha.describe)('authenticate', function () {
      (0, _mocha.beforeEach)(function () {
        session.reopen({
          authenticate: function authenticate() {
            return 'value';
          }
        });
      });

      (0, _emberMocha.it)('authenticates the session', function () {
        _sinon['default'].spy(session, 'authenticate');
        sessionService.authenticate({ some: 'argument' });

        (0, _chai.expect)(session.authenticate).to.have.been.calledWith({ some: 'argument' });
      });

      (0, _emberMocha.it)("returns the session's authentication return value", function () {
        (0, _chai.expect)(sessionService.authenticate()).to.eq('value');
      });
    });

    (0, _mocha.describe)('invalidate', function () {
      (0, _mocha.beforeEach)(function () {
        session.reopen({
          invalidate: function invalidate() {
            return 'value';
          }
        });
      });

      (0, _emberMocha.it)('invalidates the session', function () {
        _sinon['default'].spy(session, 'invalidate');
        sessionService.invalidate({ some: 'argument' });

        (0, _chai.expect)(session.invalidate).to.have.been.calledWith({ some: 'argument' });
      });

      (0, _emberMocha.it)("returns the session's invalidation return value", function () {
        (0, _chai.expect)(sessionService.invalidate()).to.eq('value');
      });
    });

    (0, _mocha.describe)('authorize', function () {
      (0, _mocha.describe)('when the session is authenticated', function () {
        (0, _mocha.beforeEach)(function () {
          sessionService.set('isAuthenticated', true);
          sessionService.set('data', { authenticated: { some: 'data' } });
        });

        (0, _emberMocha.it)('authorizes with the authorizer', function () {
          _sinon['default'].spy(authorizer, 'authorize');
          sessionService.authorize('authorizer', 'block');

          (0, _chai.expect)(authorizer.authorize).to.have.been.calledWith({ some: 'data' }, 'block');
        });
      });

      (0, _mocha.describe)('when the session is not authenticated', function () {
        (0, _mocha.beforeEach)(function () {
          sessionService.set('isAuthenticated', false);
        });

        (0, _emberMocha.it)('does not authorize', function () {
          _sinon['default'].spy(authorizer, 'authorize');
          sessionService.authorize('authorizer', 'block');

          (0, _chai.expect)(authorizer.authorize).to.not.have.been.called;
        });
      });
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/services/session-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/services/session-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/services/session-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/services/session-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/services/session-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/services/session-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/adaptive-test', ['exports', 'mocha', 'ember-simple-auth/session-stores/adaptive', 'dummy/tests/unit/session-stores/shared/store-behavior', 'dummy/tests/unit/session-stores/shared/cookie-store-behavior', 'dummy/tests/helpers/fake-cookie-service'], function (exports, _mocha, _emberSimpleAuthSessionStoresAdaptive, _dummyTestsUnitSessionStoresSharedStoreBehavior, _dummyTestsUnitSessionStoresSharedCookieStoreBehavior, _dummyTestsHelpersFakeCookieService) {

  (0, _mocha.describe)('AdaptiveStore', function () {
    var _store = undefined;

    (0, _mocha.afterEach)(function () {
      _store.clear();
    });

    (0, _mocha.describe)('when localStorage is available', function () {
      (0, _mocha.beforeEach)(function () {
        _store = _emberSimpleAuthSessionStoresAdaptive['default'].create({ _isLocalStorageAvailable: true });
      });

      (0, _dummyTestsUnitSessionStoresSharedStoreBehavior['default'])({
        store: function store() {
          return _store;
        }
      });
    });

    (0, _mocha.describe)('when localStorage is not available', function () {
      (0, _mocha.beforeEach)(function () {
        _store = _emberSimpleAuthSessionStoresAdaptive['default'].create({ _isLocalStorageAvailable: false });
        _store.set('_store._cookies', _dummyTestsHelpersFakeCookieService['default'].create());
        _store.set('_store._fastboot', { isFastBoot: false });
      });

      (0, _dummyTestsUnitSessionStoresSharedStoreBehavior['default'])({
        store: function store() {
          return _store;
        }
      });

      (0, _dummyTestsUnitSessionStoresSharedCookieStoreBehavior['default'])({
        createStore: function createStore(cookiesService) {
          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          options._isLocalStorageAvailable = false;
          var store = _emberSimpleAuthSessionStoresAdaptive['default'].create(options);
          store.set('_store._cookies', cookiesService);
          store.set('_store._fastboot', { isFastBoot: false });
          return store;
        },
        renew: function renew(store, data) {
          store.get('_store')._renew(data);
        },
        sync: function sync(store) {
          store.get('_store')._syncData();
        }
      });
    });
  });
});
define('dummy/tests/unit/session-stores/adaptive-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/session-stores/adaptive-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/session-stores/adaptive-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/adaptive-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/session-stores/adaptive-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/session-stores/adaptive-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/cookie-test', ['exports', 'mocha', 'ember-simple-auth/session-stores/cookie', 'dummy/tests/unit/session-stores/shared/store-behavior', 'dummy/tests/unit/session-stores/shared/cookie-store-behavior', 'dummy/tests/helpers/fake-cookie-service'], function (exports, _mocha, _emberSimpleAuthSessionStoresCookie, _dummyTestsUnitSessionStoresSharedStoreBehavior, _dummyTestsUnitSessionStoresSharedCookieStoreBehavior, _dummyTestsHelpersFakeCookieService) {

  function createCookieStore(cookiesService) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    options._cookies = cookiesService;
    options._fastboot = { isFastBoot: false };
    return _emberSimpleAuthSessionStoresCookie['default'].create(options);
  }

  (0, _mocha.describe)('CookieStore', function () {
    var _store = undefined;

    (0, _mocha.beforeEach)(function () {
      _store = createCookieStore(_dummyTestsHelpersFakeCookieService['default'].create());
    });

    (0, _mocha.afterEach)(function () {
      _store.clear();
    });

    (0, _dummyTestsUnitSessionStoresSharedStoreBehavior['default'])({
      store: function store() {
        return _store;
      },
      syncExternalChanges: function syncExternalChanges() {
        _store._syncData();
      }
    });

    (0, _dummyTestsUnitSessionStoresSharedCookieStoreBehavior['default'])({
      createStore: function createStore(cookiesService) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        return createCookieStore(cookiesService, options);
      },
      renew: function renew(store, data) {
        return store._renew(data);
      },
      sync: function sync(store) {
        store._syncData();
      }
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/session-stores/cookie-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/session-stores/cookie-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/session-stores/cookie-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/cookie-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/session-stores/cookie-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/session-stores/cookie-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/ephemeral-test', ['exports', 'mocha', 'ember-simple-auth/session-stores/ephemeral', 'dummy/tests/unit/session-stores/shared/store-behavior'], function (exports, _mocha, _emberSimpleAuthSessionStoresEphemeral, _dummyTestsUnitSessionStoresSharedStoreBehavior) {

  (0, _mocha.describe)('EphemeralStore', function () {
    var _store = undefined;

    (0, _mocha.beforeEach)(function () {
      _store = _emberSimpleAuthSessionStoresEphemeral['default'].create();
    });

    (0, _dummyTestsUnitSessionStoresSharedStoreBehavior['default'])({
      store: function store() {
        return _store;
      }
    });
  });
});
define('dummy/tests/unit/session-stores/ephemeral-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/session-stores/ephemeral-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/session-stores/ephemeral-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/ephemeral-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/session-stores/ephemeral-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/session-stores/ephemeral-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/local-storage-test', ['exports', 'mocha', 'ember-simple-auth/session-stores/local-storage', 'dummy/tests/unit/session-stores/shared/store-behavior'], function (exports, _mocha, _emberSimpleAuthSessionStoresLocalStorage, _dummyTestsUnitSessionStoresSharedStoreBehavior) {

  (0, _mocha.describe)('LocalStorageStore', function () {
    var _store = undefined;

    (0, _mocha.beforeEach)(function () {
      _store = _emberSimpleAuthSessionStoresLocalStorage['default'].create();
    });

    (0, _mocha.afterEach)(function () {
      _store.clear();
    });

    (0, _dummyTestsUnitSessionStoresSharedStoreBehavior['default'])({
      store: function store() {
        return _store;
      }
    });
  });
});
define('dummy/tests/unit/session-stores/local-storage-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/session-stores/local-storage-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/session-stores/local-storage-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/local-storage-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/session-stores/local-storage-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/session-stores/local-storage-test.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/shared/cookie-store-behavior', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai', 'sinon', 'dummy/tests/helpers/fake-cookie-service'], function (exports, _ember, _emberMocha, _mocha, _chai, _sinon, _dummyTestsHelpersFakeCookieService) {
  exports['default'] = function (options) {
    var store = undefined;
    var createStore = undefined;
    var renew = undefined;
    var sync = undefined;
    var cookieService = undefined;

    (0, _mocha.beforeEach)(function () {
      createStore = options.createStore;
      renew = options.renew;
      sync = options.sync;
      cookieService = _dummyTestsHelpersFakeCookieService['default'].create();
      _sinon['default'].spy(cookieService, 'read');
      _sinon['default'].spy(cookieService, 'write');
      store = createStore(cookieService);
    });

    (0, _mocha.afterEach)(function () {
      cookieService.read.restore();
      cookieService.write.restore();
      store.clear();
    });

    (0, _mocha.describe)('#persist', function () {
      (0, _emberMocha.it)('respects the configured cookieName', function () {
        store = createStore(cookieService, { cookieName: 'test:session' });
        store.persist({ key: 'value' });

        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('test:session', JSON.stringify({ key: 'value' }), { domain: null, expires: null, path: '/', secure: false });
      });

      (0, _emberMocha.it)('respects the configured cookieDomain', function () {
        store = createStore(cookieService, { cookieDomain: 'example.com' });
        store.persist({ key: 'value' });

        (0, _chai.expect)(cookieService.write).to.have.been.calledWith('ember_simple_auth:session', JSON.stringify({ key: 'value' }), { domain: 'example.com', expires: null, path: '/', secure: false });
      });
    });

    (0, _mocha.describe)('#renew', function () {
      (0, _mocha.beforeEach)(function (done) {
        store = createStore(cookieService, {
          cookieName: 'test:session',
          cookieExpirationTime: 60,
          expires: new Date().getTime() + store.cookieExpirationTime * 1000
        });
        store.persist({ key: 'value' });
        renew(store).then(done);
      });

      // TODO: the ":expiration_time" never actually seems to get written
      (0, _emberMocha.it)('stores the expiration time in a cookie named "test:session:expiration_time"');
    });

    (0, _mocha.describe)('the "sessionDataUpdated" event', function () {
      var triggered = undefined;

      (0, _mocha.beforeEach)(function () {
        triggered = false;
        store.persist({ key: 'value' });
        store.one('sessionDataUpdated', function () {
          triggered = true;
        });
      });

      (0, _emberMocha.it)('is not triggered when the cookie has not actually changed', function (done) {
        document.cookie = 'ember_simple_auth:session=%7B%22key%22%3A%22value%22%7D;path=/;';
        sync(store);

        _ember['default'].run.next(function () {
          (0, _chai.expect)(triggered).to.be['false'];
          done();
        });
      });

      (0, _emberMocha.it)('is triggered when the cookie changed', function (done) {
        var cookiesService = store.get('_cookies') || store.get('_store._cookies');
        cookiesService._content['ember_simple_auth:session'] = '%7B%22key%22%3A%22other%20value%22%7D';
        sync(store);

        _ember['default'].run.next(function () {
          _ember['default'].run.next(function () {
            (0, _chai.expect)(triggered).to.be['true'];
            done();
          });
        });
      });

      (0, _emberMocha.it)('is not triggered when the cookie expiration was renewed', function (done) {
        renew(store, { key: 'value' });
        sync(store);

        _ember['default'].run.next(function () {
          (0, _chai.expect)(triggered).to.be['false'];
          done();
        });
      });
    });
  };
});
/* jshint expr:true */
define('dummy/tests/unit/session-stores/shared/cookie-store-behavior.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/session-stores/shared/cookie-store-behavior.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/session-stores/shared/cookie-store-behavior.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/shared/cookie-store-behavior.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/session-stores/shared/cookie-store-behavior.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/session-stores/shared/cookie-store-behavior.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/shared/store-behavior', ['exports', 'ember', 'ember-mocha', 'mocha', 'chai'], function (exports, _ember, _emberMocha, _mocha, _chai) {
  exports['default'] = function (options) {
    var syncExternalChanges = options.syncExternalChanges || _ember['default'].K;
    var store = undefined;

    (0, _mocha.beforeEach)(function () {
      store = options.store();
    });

    (0, _mocha.describe)('#persist', function () {
      (0, _emberMocha.it)('persists an object', function () {
        return store.persist({ key: 'value' }).then(function () {
          return store.restore().then(function (restoredContent) {
            (0, _chai.expect)(restoredContent).to.eql({ key: 'value' });
          });
        });
      });

      (0, _emberMocha.it)('overrides existing data', function () {
        return store.persist({ key1: 'value1' }).then(function () {
          return store.persist({ key2: 'value2' }).then(function () {
            return store.restore().then(function (restoredContent) {
              (0, _chai.expect)(restoredContent).to.eql({ key2: 'value2' });
            });
          });
        });
      });

      (0, _emberMocha.it)('does not trigger the "sessionDataUpdated" event', function (done) {
        var triggered = false;
        store.one('sessionDataUpdated', function () {
          return triggered = true;
        });
        store.persist({ key: 'other value' });
        syncExternalChanges();

        _ember['default'].run.next(function () {
          (0, _chai.expect)(triggered).to.be['false'];
          done();
        });
      });
    });

    (0, _mocha.describe)('#restore', function () {
      (0, _mocha.describe)('when the store is empty', function () {
        (0, _emberMocha.it)('returns an empty object', function () {
          return store.clear().then(function () {
            return store.restore().then(function (restoredContent) {
              (0, _chai.expect)(restoredContent).to.eql({});
            });
          });
        });
      });

      (0, _mocha.describe)('when the store has data', function () {
        (0, _mocha.beforeEach)(function () {
          return store.persist({ key1: 'value1', key2: 'value2' });
        });

        (0, _emberMocha.it)('returns all data in the store', function () {
          return store.restore().then(function (restoredContent) {
            (0, _chai.expect)(restoredContent).to.eql({ key1: 'value1', key2: 'value2' });
          });
        });

        (0, _emberMocha.it)('returns a copy of the stored data', function () {
          return store.restore().then(function (data) {
            data.key1 = 'another value!';

            return store.restore().then(function (restoredContent) {
              (0, _chai.expect)(restoredContent).to.eql({ key1: 'value1', key2: 'value2' });
            });
          });
        });
      });
    });

    (0, _mocha.describe)('#clear', function () {
      (0, _emberMocha.it)('empties the store', function () {
        return store.persist({ key1: 'value1', key2: 'value2' }).then(function () {
          return store.clear().then(function () {
            return store.restore().then(function (restoredContent) {
              (0, _chai.expect)(restoredContent).to.eql({});
            });
          });
        });
      });
    });
  };
});
/* jshint expr:true */
define('dummy/tests/unit/session-stores/shared/store-behavior.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/session-stores/shared/store-behavior.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/session-stores/shared/store-behavior.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/session-stores/shared/store-behavior.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/session-stores/shared/store-behavior.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/session-stores/shared/store-behavior.js should pass jshint.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/utils/objects-are-equal-test', ['exports', 'ember-mocha', 'mocha', 'chai', 'ember-simple-auth/utils/objects-are-equal'], function (exports, _emberMocha, _mocha, _chai, _emberSimpleAuthUtilsObjectsAreEqual) {

  (0, _mocha.describe)('objectsAreEqual', function () {
    (0, _emberMocha.it)('is true for equal objects', function () {
      (0, _chai.expect)((0, _emberSimpleAuthUtilsObjectsAreEqual['default'])({ a: 'b', c: 'd' }, { a: 'b', c: 'd' })).to.be['true'];
    });

    (0, _emberMocha.it)('is true for equal objects regardless of property order', function () {
      (0, _chai.expect)((0, _emberSimpleAuthUtilsObjectsAreEqual['default'])({ a: 'b', c: 'd' }, { c: 'd', a: 'b' })).to.be['true'];
    });

    (0, _emberMocha.it)('is true for equal nested objects regardless of property order', function () {
      (0, _chai.expect)((0, _emberSimpleAuthUtilsObjectsAreEqual['default'])({ a: 'b', c: 'd', e: { f: 'g' } }, { e: { f: 'g' }, a: 'b', c: 'd' })).to.be['true'];
    });

    (0, _emberMocha.it)('is true for equal objects that include arrays', function () {
      (0, _chai.expect)((0, _emberSimpleAuthUtilsObjectsAreEqual['default'])({ a: ['b', 'c'] }, { a: ['b', 'c'] })).to.be['true'];
    });

    (0, _emberMocha.it)('is false for equal objects that include differently ordered arrays', function () {
      (0, _chai.expect)((0, _emberSimpleAuthUtilsObjectsAreEqual['default'])({ a: ['b', 'c'] }, { a: ['c', 'b'] })).to.be['false'];
    });

    (0, _emberMocha.it)('is false for unequal objects', function () {
      (0, _chai.expect)((0, _emberSimpleAuthUtilsObjectsAreEqual['default'])({ a: 'b' }, { c: 'd' })).to.be['false'];
    });
  });
});
/* jshint expr:true */
define('dummy/tests/unit/utils/objects-are-equal-test.jscs-test', ['exports'], function (exports) {
  'use strict';

  describe('JSCS - unit/utils/objects-are-equal-test.js', function () {
    it('should pass jscs', function () {
      expect(true, 'unit/utils/objects-are-equal-test.js should pass jscs.').to.be.ok;
    });
  });
});
define('dummy/tests/unit/utils/objects-are-equal-test.jshint', ['exports'], function (exports) {
  'use strict';

  describe('JSHint - unit/utils/objects-are-equal-test.js', function () {
    it('should pass jshint', function () {
      expect(true, 'unit/utils/objects-are-equal-test.js should pass jshint.').to.be.ok;
    });
  });
});
/* jshint ignore:start */

require('dummy/tests/test-helper');
EmberENV.TESTS_FILE_LOADED = true;

/* jshint ignore:end */
//# sourceMappingURL=tests.map